#!/usr/bin/env Rscript

# the command line api of data analysis of biological experiments
if (!requireNamespace('argparse', quietly = TRUE)) {
  stop("Please install argparse to parse the command line paramters!")
}
suppressPackageStartupMessages( library("argparse") )
suppressPackageStartupMessages( library("magrittr") )

# ****************** COMMAND LINE PARAMETERS SETTING ****************

# ======================= GLOBAL command line parameters setting=================
parser = ArgumentParser(description = "single cell analysis results visualization toolsets.", usage = "%(prog)s [global options]" )
parser$add_argument("-i", "--input", type = "character",
             help = "The input exprssion matrix in several possible format.")
parser$add_argument("-f", "--informat", type = "character", default = NULL,
             help = "The format of data object, the possible choices can be:h5seurat,(seurat)rds,(sce)rds, loom.[default: %(default)s]")
parser$add_argument("-o", "--output", type = "character", default = "./",
             help = "the output directory of results."  )
#parser$add_argument("-p", "--prefix", type = "character", default = "seurat",
#             help = "the prefix of output file without file extension.[default %(default)s]")
parser$add_argument("-t", "--ncores", type="integer", default = 10,
             help="the number of CPUs used to improve the performace.[default: %(default)s]")
parser$add_argument("--assay", type = "character", default = NULL,
             help = "the main assay object to use. When it come to multimodal assay this is the assay used to initialize the object, all the other assays will merged into it.")
parser$add_argument("--subassay", type = "character", default = NULL,
             help = "[OPTIONAL]the comma separated assays list except the main assay specified by --assay, when it comes to multimodal experiment. For monomodal assay, it's NULL as default.")
parser$add_argument("--slot", type="character", default="data",
             help="the data slot in the specified assay used for this run, only choices:'counts','data'.[default: %(default)s]")
parser$add_argument("--reduct", type = "character", default = "umap",
             help = "[OPTIONAL]name(s) of reductions[default: %(default)s].NULL:all reductions,NA:only global reductions,FALSE:no reductions.  Note: Only reductions associated with an assay loaded in assays or marked as global will be loaded.")
parser$add_argument("--predicate", type = "character", default = NULL,
             help = "The conditional expression to subset cells used for subtyping.[default: %(default)s]")
parser$add_argument("--saveggobject", type = "logical", default = FALSE,
              help = "Wether to save the ggplot2 object of the plot for later modification.[default: %(default)s]")

subparsers = parser$add_subparsers(help = "subcommands:")


# subcommands' command line interface definition start from here.
sub_elbow = subparsers$add_parser("elbow", help = "the elbow plot of components variance.")
sub_summarize = subparsers$add_parser("summarize", help = "the summarizing plot of QC")

sub_jackstraw = subparsers$add_parser("jackstraw", help = "the jackstraw plot")
sub_jackstraw$add_argument("--components", type = "integer", default = 20,
         help = "[OPTIONAL]the dimensions used for visualization or calibration.[default: %(default)s]")

sub_dimplot = subparsers$add_parser("dimplot", help = "scatter plot with cell annotations")
sub_dimplot$add_argument("-g", "--groupby", type = "character", default = "ident",
        help = "[OPTIONAL]The grouppinig variable in the metadata for groupping cells in the scatter plot. If not specified, %(default)s will be used as default.")
sub_dimplot$add_argument("-y", "--splitby", type = "character", default = NULL,
        help = "[OPTIONAL]the variable in the metadata used to split the graph by the variable levels to comparing the gene expression difference in different levels.")
sub_dimplot$add_argument("--palette", type = "character", default = "customecol2",
        help = "the discrete color schema mapped to the cell annotations specified by --groupby.[default: %(default)s] Choices:blindless:69,cold:32,glasbey:32,ditto:24,alphabet:26,alphabet2:26,colx22:22,cyclic:20,tableau20:20,Buen:17,UKBB:18,TF1:17,paired:12")
sub_dimplot$add_argument("-s", "--pointsize", type = "double", default = 0.5,
        help = "[OPTIONAL]the point size in the plot.")
sub_dimplot$add_argument("--ncol", type = "integer", default = 2,
        help = "[OPTIONAL]Number of columns for display when combining plots.")
sub_dimplot$add_argument("--shuffle", type = "logical", default = FALSE,
        help = "[OPTIONAL]Whether to randomly shuffle the order of points. This can be useful for crowded plots if points of interest are being buried.[default: %(default)s].")
sub_dimplot$add_argument("--label", type = "logical", default = FALSE,
        help = "Whether to label the clusters.[default: %(default)s]")
sub_dimplot$add_argument("--images", type = "character", default = FALSE,
        help = "[OPTIONAL]images only availiable for spatial transcriptomics.[default: %(default)s]")
sub_dimplot$add_argument("--highlight", type = "character", default = NULL,
        help = "the logical expression for selecting specific cells to be highlighted on the scatter plots.[default: %(default)s]")

sub_dense = subparsers$add_parser("density", help = "density plot with features in cell communities.")
sub_dense$add_argument("-l", "--markers",type ="character",
        help="the file of marker genes table to be visulized.")
sub_dense$add_argument("-n", "--topn", type="integer", default = 1,
        help = "the number of top markers for each cluster to visualizse.")
sub_dense$add_argument("-c", "--topby", type = "character", default = "gene_diff",
        help="the column used to pick top n marker genes.The option can be one of the column in the input marker genes table.")
sub_dense$add_argument("-x", "--extraGene", type = "character", default = NULL,
        help = "[OPTIONAL]The extra gene list of interest to visualize specified by the user.")
sub_dense$add_argument("-g", "--groupby", type = "character", default = "clusters",
        help = "[OPTIONAL]The grouppinig variable in the metadata for separate the cells to visulize marker genes.")
sub_dense$add_argument("-y", "--splitby", type = "character", default = NULL,
        help = "[OPTIONAL]the variable in the metadata used to split the graph by the variable levels to comparing the gene expression difference in different levels.")
sub_dense$add_argument("--color-scale", type = "character", default = "grey,red",
        help = "[OPTIONAL]the color scale used to map the gene expression value,format:low_color,high_color.[default: %(default)s]")
sub_dense$add_argument("-s", "--pointsize", type = "double", default = 0.5,
        help = "[OPTIONAL]the point size in the plot.")
#sub_dense$add_argument("--reduct", type = "character", default = "umap",
#        help = "[OPTIONAL]the previous calculated reduction result used in the featureplot,.")
sub_dense$add_argument("--combine", type = "logical", default = F,
        help = "whether to plot the gene pairs in the same plot.[default: %(default)s]")
#
sub_dotplot = subparsers$add_parser("dotplot", help = "visualize the marker using dotplot")
sub_dotplot$add_argument("-l", "--markers",type ="character",
        help="the file of marker genes table to be visulized.")
sub_dotplot$add_argument("-n", "--topn", type="integer", default = 1,
        help = "the number of top ranked markers for each cluster to visualizse.")
sub_dotplot$add_argument("-c", "--topby", type = "character", default = "gene_diff",
        help="the column used to pick top n marker genes.The option can be one of the column in the input marker genes table.")
sub_dotplot$add_argument("-x", "--extraGene", type = "character", default = NULL,
        help = "[OPTIONAL]The extra gene list of interest to visualize specified by the user.")
sub_dotplot$add_argument("-g", "--groupby", type = "character", default = "clusters",
        help = "[OPTIONAL]The grouppinig variable in the metadata for separate the cells to visulize marker genes.")
sub_dotplot$add_argument("-y", "--splitby", type = "character", default = NULL,
        help = "[OPTIONAL]the variable in the metadata used to split the graph by the variable levels to comparing the gene expression difference in different levels.")
sub_dotplot$add_argument("-s", "--pointsize", type = "double", default = 0.5,
        help = "[OPTIONAL]the point size in the plot. If you prefer no points, please set it as 0.")
sub_dotplot$add_argument( "--row-splitby", type = "character", default = NULL,
          help = "the row annotation variable used to split the row of the matrix to display.")

sub_vlnplot = subparsers$add_parser("vlnplot", help = "visualize the marker using violin plot.")
sub_vlnplot$add_argument("-l", "--markers",type ="character",
        help="the file of marker genes table to be visulized.")
sub_vlnplot$add_argument("-n", "--topn", type="integer", default = 1,
        help = "the number of top ranked markers for each cluster to visualizse.")
sub_vlnplot$add_argument("-c", "--topby", type = "character", default = "gene_diff",
        help="the column used to pick top n marker genes.The option can be one of the column in the input marker genes table.")
sub_vlnplot$add_argument("-x", "--extraGene", type = "character", default = NULL,
        help = "[OPTIONAL]The extra gene list of interest to visualize specified by the user.")
sub_vlnplot$add_argument("-g", "--groupby", type = "character", default = "clusters",
        help = "[OPTIONAL]The grouppinig variable in the metadata for separate the cells to visulize marker genes.")
sub_vlnplot$add_argument("-y", "--splitby", type = "character", default = NULL,
        help = "[OPTIONAL]the variable in the metadata used to split the graph by the variable levels to comparing the gene expression difference in different levels.")
sub_vlnplot$add_argument("-s", "--pointsize", type = "double", default = 0.1,
        help = "[OPTIONAL]the point size in the plot. If you prefer no points, please set it as 0.")
sub_vlnplot$add_argument("-a", "--alpha2use", type = "double", default = 0,
        help = "[OPTIONAL]the opacity of the pooints on the violin plot.")
sub_vlnplot$add_argument("--dodge", type = "logical", default = TRUE,
        help = "[OPTIONAL]visualize the feature between the contrast groups separately for each level in variable specified by --groupby.")

sub_stackvln = subparsers$add_parser("stackvln", help = "visualize the marker using stacked violin plot.")
sub_stackvln$add_argument("-l", "--markers",type ="character",
        help="the file of marker genes table to be visulized.")
sub_stackvln$add_argument("-n", "--topn", type="integer", default = 1,
        help = "the number of top ranked markers for each cluster to visualizse.")
sub_stackvln$add_argument("-c", "--topby", type = "character", default = "gene_diff",
        help="the column used to pick top n marker genes.The option can be one of the column in the input marker genes table.")
sub_stackvln$add_argument("-x", "--extraGene", type = "character", default = NULL,
        help = "[OPTIONAL]The extra gene list of interest to visualize specified by the user.")
sub_stackvln$add_argument("-g", "--groupby", type = "character", default = "clusters",
        help = "[OPTIONAL]The grouppinig variable in the metadata for separate the cells to visulize marker genes.")
sub_stackvln$add_argument("-y", "--splitby", type = "character", default = NULL,
        help = "[OPTIONAL]the variable in the metadata used to split the graph by the variable levels to comparing the gene expression difference in different levels.")
sub_stackvln$add_argument("-s", "--pointsize", type = "double", default = 0.1,
        help = "[OPTIONAL]the point size in the plot. If you prefer no points, please set it as 0.")
sub_stackvln$add_argument("-a", "--alpha2use", type = "double", default = 0,
        help = "[OPTIONAL]the opacity of the pooints on the violin plot.")
sub_stackvln$add_argument("--flip", type = "logical", default = TRUE,
        help = "[OPTIONAL]wether to flip the coordination of the plot.")
sub_stackvln$add_argument("--dodge", type = "logical", default = TRUE,
        help = "[OPTIONAL]visualize the feature between the contrast groups separately for each level in variable specified by --groupby.")

sub_features = subparsers$add_parser("featureplot", help = "visualize the bunch of features in a featureplot.")
sub_features$add_argument("-l", "--markers",type ="character",
        help="the file of marker genes table to be visulized.")
sub_features$add_argument("-n", "--topn", type="integer", default = 1,
        help = "the number of top markers for each cluster to visualizse.")
sub_features$add_argument("-c", "--topby", type = "character", default = "gene_diff",
        help="the column used to pick top n marker genes.The option can be one of the column in the input marker genes table.")
sub_features$add_argument("-x", "--extraGene", type = "character", default = NULL,
        help = "[OPTIONAL]The extra gene list of interest to visualize specified by the user.")
sub_features$add_argument("-g", "--groupby", type = "character", default = "clusters",
        help = "[OPTIONAL]The grouppinig variable in the metadata for separate the cells to visulize marker genes.")
sub_features$add_argument("-y", "--splitby", type = "character", default = NULL,
        help = "[OPTIONAL]the variable in the metadata used to split the graph by the variable levels to comparing the gene expression difference in different levels.")
sub_features$add_argument("--color-scale", type = "character", default = "grey,red",
        help = "[OPTIONAL]the color scale used to map the gene expression value,format:low_color,high_color.[default: %(default)s]")
sub_features$add_argument("-s", "--pointsize", type = "double", default = 0.5,
        help = "[OPTIONAL]the point size in the plot.")
#sub_features$add_argument("--reduct", type = "character", default = "umap",
#        help = "[OPTIONAL]the previous calculated reduction result used in the featureplot,.")
## sub_heatmap ========================
sub_heatmap = subparsers$add_parser("heatmap", help = "visualize the bunch of features in a heatmap using ComplexHeatmap.")
sub_heatmap$add_argument("-l", "--markers",type ="character",
        help="the file of marker genes table to be visulized.")
sub_heatmap$add_argument( "-g", "--groupby", type = "character", default = "ident",
          help = "the groupping variable name for columns in column metadata.")
sub_heatmap$add_argument("-n", "--topn", type="integer", default = 5,
        help = "the number of top markers for each cluster to visualizse.")
sub_heatmap$add_argument("-c", "--topby", type = "character", default = "gene_diff",
        help="the column used to pick top n marker genes.The option can be one of the column in the input marker genes table.")
sub_heatmap$add_argument("-x", "--extraGene", type = "character", default = NULL,
        help = "[OPTIONAL]The extra gene list of interest to visualize specified by the user.")
sub_heatmap$add_argument("--group_colors", type = "character", default="customecol2",
          help = "one or more color schema names list for each groupping variables including the additional groups if supplied.[default: %(default)s]")
sub_heatmap$add_argument( "--row_marks", type = "character", default = NULL,
          help = "[OPTIONAL]the additional row/features names list to highlight with padding style.")
sub_heatmap$add_argument("--sample_ratio", type = "double", default = NULL,
          help = "[OPTIONAL]the ratio of random subsample for each group when drawing heatmap.")
sub_heatmap$add_argument("--style", type = "character", default = "seurat",
          help = "[OPTIOANL]the plot style for heatmap, seurat or complexheatmap.")
#sub_heatmap$add_argument( "--row_annovar", type = "character", default = NULL,
##          help = "[OPTIONAL]the row/features annotation varibale name in the row/features annotation metadata.")
##sub_heatmap$add_argument( "--row_splitby", type = "character", default = NULL,
##          help = "[OPTIONAL]the row annotation variable used to split the row of the matrix to display.")
##sub_heatmap$add_argument( "--row_colors", type = "character", default = NULL,
##          help = "[OPTIONAL]the color schema name for row annotations.")
sub_heatmap$add_argument( "--extra_groups", type = "character", default = NULL,
          help = "[Cheat] the comma separated names list of additional groupping variables for columns in column metadata.")
sub_heatmap$add_argument( "-r", "--group_orderby", type = "character", default = NULL,
          help = "[Cheat]one or more groups(comma separated) names to order the columns of matrix.")
sub_heatmap$add_argument( "-b", "--col_splitby", type = "character", default = "ident",
          help = "[OPTIONAL][Cheat]one of the groupping variables in '--group-by' and 'extra-groups' used to split the columns of matrix to display.")
sub_heatmap$add_argument( "--row_txtsize", type = "character", default = 5.5,
          help = "[Cheat] the size of row text labels." )
sub_heatmap$add_argument( "--value_colors", type = "character", default = "#FF08BD,#000000,#FFF42F",
          help = "[Cheat] the color scale used mapping the value of each cell in the matrix.[default: %(default)s] Format can be:low_color, middle_color, high_color.")
# diff heatmap ==============
sub_diff_heatmap = subparsers$add_parser("diff_heatmap", help = "visualize top DEG on a heatmap.")
sub_diff_heatmap$add_argument("-d", "--diffGene",type ="character",
        help="The diff gene list of interest to visualize specified by the user.")
sub_diff_heatmap$add_argument("-n", "--topn",type ="integer", default = 20,
        help="the number of top markers for each cluster to visualizse.")
sub_diff_heatmap$add_argument("--sample_ratio",type ="double",default = 0.8,
        help="the ratio of random subsample for each group when drawing heatmap.")
sub_diff_heatmap$add_argument("--group_colors", type = "character", default="customecol2",
        help = "one or more color schema names list for each groupping variables including the additional groups if supplied.[default: %(default)s]")
sub_diff_heatmap$add_argument("-g","--groupby", type = "character", default="NULL",
        help = "The grouppinig variable in the metadata for separate the cells to visulize marker genes.")

# coefficient heatmap ==============
sub_coefficient = subparsers$add_parser("coefficient", help = "export the gene expression in different group sepecified by the user.")
sub_coefficient$add_argument("-g", "--groupby", type="character", default="ident",
             help="[OPTIONAL]The grouppinig variable in the metadata for separate the cells to calculate the correlation.[default: clusters]")
# sub_coefficient$add_argument("--reduct", type="character", default="umap",
#              help = "[OPTIONAL]the reduction results used to embedding the coefficient heatmap.[default: %(default)s]")

## sub_pseudotimeplots ========================
sub_monocle_vis = subparsers$add_parser("monocle_vis", help = "visualize the monocle plots.")
sub_monocle_vis$add_argument("-g", "--genelist",type ="character",default= NULL,
        help="The genelist used to plot heatmap with header.")
sub_monocle_vis$add_argument("-m", "--vismethod",type ="character",default= NULL,
        help="the visulization methods for genes.The methods can be all, heatmap, expressplot, trajectoryplot, treeplot, module.")
sub_monocle_vis$add_argument("--root",type ="integer",default= NULL,
        help="[Otional] The state designate as root.")        
sub_monocle_vis$add_argument("--show_branch",type ="logical",default= FALSE,
        help="Whether to display cell_trajectory_color_by_Pseudotime branch, Used with the root parameter.Prepare for branch heatmap")
sub_monocle_vis$add_argument("-n", "--clusters",type ="integer",default= 4,
        help="[Heatmap] Number of clusters for the heatmap of branch genes.")        
sub_monocle_vis$add_argument("-b", "--branchpoint",type ="integer",default= NULL,
        help="[Heatmap] The branch point used in the branch-heatmap.")
sub_monocle_vis$add_argument("--showname",type ="logical",default= NULL,
        help="[Heatmap] Whether to display the row name.")
sub_monocle_vis$add_argument("-c", "--groupby",type ="character",default= "clusters",
        help="[expressplot, treeplot] The grouppinig variable in pseudotime_gene_express. e.g. orig.ident")
sub_monocle_vis$add_argument("-l", "--numcol",type ="integer",default= 2,
        help="[expressplot] the number of columns used when laying out the panels for each gene's expression.")
sub_monocle_vis$add_argument("-s", "--pointsize",type ="double",default= 0.8,
        help="[expressplot & trajectoryplot] The point size in the plot.")
sub_monocle_vis$add_argument("--module",type ="character",default= NULL,
        help="[module expressplot] the module information (for genes) from the heatmap clustering.")
sub_monocle_vis$add_argument("--topn",type ="integer",default= 25,
        help="the number of top DEGs to visualizse.")
sub_monocle_vis$add_argument("--toptype",type ="character",default= "both",
        help="choose from up,down,or both DEGs to visualizse.")
sub_monocle_vis$add_argument("-v", "--input_sc",type ="character",default= NULL,
        help="The scenic result with auc data in RDS format.")        
sub_monocle_vis$add_argument("-t", "--sc_genelist",type ="character",default= NULL,
        help="The TF genelist used to plot with header.")
sub_monocle_vis$add_argument("-a", "--anno",type ="character",default= NULL,
        help="[Heatmap] Annotation file.")        
sub_monocle_vis$add_argument("--nbin",type ="integer",default= 50,
        help="[bin] number of bins.")


opt = parser$parse_args()
args<-commandArgs(TRUE)
#================== GLOBAL PARAMETERS PARSING ===================================
# setting the output directory
if ( is.null(opt$output) ){
    print("NO output directory specified,the current directory will be used!")
    output_dir = getwd()
}else{
    if ( file.exists(opt$output) ){
        output_dir = opt$output
    }else{
        output_dir = opt$output
        dir.create(output_dir,recursive = T)
    }
}
output_dir = normalizePath(output_dir )

# save gpgplot2 object of plot or not
is.saveggplot = as.logical(opt$saveggobject)

# check the input data object
if ( is.null(opt$slot) ){
  dataslots = NULL
}else{
  dataslots = unlist( strsplit(opt$slot, ","))
}

if ( !is.null(opt$subassay) ){
  assays =  c(opt$assay, unlist(strsplit(opt$subassay,",")))
}else{
  assays = opt$assay
}
assays = unique(assays)

if ( !is.null(opt$reduct) ){
  opt$reduct =   strsplit(opt$reduct, ",")
}

options(future.globals.maxSize= Inf ) # setting the maxumium mermory usage much bigger in case of big data
future::plan("multicore", workers = min(future::availableCores(), opt$ncores)) # parallization using specified CPUs start from here


# ======================== Subcmd: heatmap ==================================
if ( "heatmap" %in% args ){
  if ( is.null( opt$markers ) & is.null(opt$extraGene)){
      stop("NO marker genes is AVAILABLE!")
  }

  # read the specified assay and data slot in data object into memory
  # for visualization usually only "data" slot is loaded,which can save a lot of time and memory
  data_ob = OESingleCell::ReadX(
             input = opt$input, informat = opt$informat,
             assays = assays, data.use = dataslots, # "data","scale.data"
             reductions = opt$reduct, graphs = FALSE, images = FALSE, # no graph object needed here
             verbose = FALSE)

  # prepare markers to be visualized
  topn_markers = data.frame()
  if ( !is.null(opt$markers) ){
      markers2vis = read.table( opt$markers, sep="\t", header = T )
      markers2vis[["cluster"]] = factor(markers2vis[["cluster"]] , levels = sort(unique(data_ob@meta.data[[opt$groupby]])))
      topn_markers  = markers2vis %>%
          dplyr::group_by(cluster) %>%
          # dplyr::arrange(p_val, desc(avg_log2FC)) %>%
          dplyr::arrange(desc(gene_diff)) %>%
          dplyr::top_n(opt$topn, wt = !!rlang::sym(opt$topby) ) %>%
          dplyr::arrange(cluster) %>%
          dplyr::mutate(folder_suffix = paste0("cluster",cluster)) %>%
          dplyr::select(cluster,gene,folder_suffix)
  }

  # add extra customized genes if existis
  if ( !is.null(opt$extraGene) ){
    extra_gene = read.table(opt$extraGene, sep="\t", header = T)
    if (dim(extra_gene)[2] == 1 && colnames(extra_gene)[1] == "gene"){colnames(extra_gene)[1]="extra"}
    formated_extra_gene = as.data.frame(tidyr::gather(extra_gene,key = "cluster",value = "GENE"))
    match = OESingleCell::CaseMatch(search = as.vector(formated_extra_gene$GENE),match = rownames(data_ob))
    formated_extra_gene = formated_extra_gene %>%
                          dplyr::filter(GENE %in% names(match)) %>%
                          dplyr::mutate(gene = match,folder_suffix = cluster) %>%
                          dplyr::select(cluster, gene,folder_suffix)
    topn_markers = rbind(topn_markers, formated_extra_gene)
  }

  markers2vis4heatmap = unique(as.vector(topn_markers$gene))
#  if (nrow(data_ob[['RNA']]@scale.data)!=nrow(data_ob[['RNA']]@data)){
  data_ob<-Seurat::ScaleData(data_ob,
                           features = markers2vis4heatmap, ## 更改为只针对marker基因进行scale,以减小内存压力
                           verbose = T )
#  }
  #get subset of cells used col.name = col.name = or visualization if necessay
  if ( !is.null(opt$predicate) ){
    df = OESingleCell::colData(data_ob)
    desired_cells= subset(df, eval( parse(text=opt$predicate)))
    data_ob = data_ob[, rownames(desired_cells)]
  }

  # downsample to specified ratio in case of too many cells to plot
  cellmeta = OESingleCell::colData(data_ob)
  if ( !is.null(opt$sample_ratio) ){
      sampled_cellmeta = cellmeta %>% tibble::rownames_to_column() %>%
                         dplyr::group_by( .dots= opt$groupby ) %>%
                         dplyr::sample_frac( size = opt$sample_ratio,replace = F) %>%
                         tibble::column_to_rownames()
      data_ob = data_ob[, rownames(sampled_cellmeta)]
  }
    data_ob = Seurat::SetIdent( data_ob, value = opt$groupby )
    data_ob@meta.data[[opt$groupby]] <- factor( data_ob@meta.data[[opt$groupby]],levels=unique(sort(data_ob@meta.data[[ opt$groupby]] )))

  if ( !is.null(opt$group_orderby) ){
     opt$group_orderby = opt$groupby
  }
  clusters = cellmeta[[opt$groupby]]
  # data_ob[[opt$groupby]] = factor(clusters, levels = sort( unique(as.numeric(clusters))))
  # data_ob[[groupby]] = as.factor(data_ob[[groupby]])

  # color settings
  group_colors = unlist(strsplit(opt$group_colors, ",", perl = T))
  if ( !is.null(opt$extra_groups) ){
    extra_groups = unlist(strsplit(opt$extra_groups, ",", perl = T))
  }else{
    extra_groups = NULL
  }
  names(group_colors) = union(opt$groupby, extra_groups )

  # if ( !is.null(opt$row_annovar) ){
  # }

  if ( !is.null(opt$row_marks)){
    row_markers = read.table(opt$extraGene, sep="\t", header = T)
    row_markers = as.vector(extra_gene[,1])
  }else{
    row_markers = NULL
  }

  value_colors = unlist(strsplit(opt$value_colors, ",", perl = T))
  colors2use = OESingleCell::SelectColors(1:length(unique(OESingleCell::colData(data_ob)[[opt$groupby]])),palette=group_colors)

  ## match opt$groupby information 
  if (opt$groupby != "clusters"){
    if ( is.factor(OESingleCell::colData(data_ob)[[opt$groupby]]) ){
        names(colors2use)=levels(OESingleCell::colData(data_ob)[[opt$groupby]])
    }else{
        names(colors2use)=unique(OESingleCell::colData(data_ob)[[opt$groupby]])
    }
  }

  if (opt$groupby == "new_celltype" & "new_celltype_col" %in% colnames(data_ob@meta.data)){
    ident2use=opt$groupby
    if ( class(data_ob@meta.data[,ident2use])=="factor" ){
        nlevel = length(unique(data_ob@meta.data[,ident2use]))
        nlevel_list = levels(data_ob@meta.data[,ident2use])
        tmp_df <- unique(data_ob@meta.data[c("new_celltype","new_celltype_col")])
        new_celltype_pal <- as.vector(tmp_df$new_celltype_col)
        names(new_celltype_pal) <-  as.vector(tmp_df$new_celltype)
        new_celltype_pal = new_celltype_pal[nlevel_list]
        user_color_pal = as.vector(new_celltype_pal)
    }else{
        nlevel = length(unique(data_ob@meta.data[,ident2use]))
        nlevel_list = sort(as.character(unique(data_ob@meta.data[,ident2use])))
        tmp_df <- unique(data_ob@meta.data[c("new_celltype","new_celltype_col")])
        new_celltype_pal <- as.vector(tmp_df$new_celltype_col)
        names(new_celltype_pal) <-  as.vector(tmp_df$new_celltype)
        new_celltype_pal = new_celltype_pal[nlevel_list]
        user_color_pal = as.vector(new_celltype_pal)
    } 
    colors2use = new_celltype_pal
  }

  if (length(markers2vis4heatmap) > 135){
    sz = 4-log(length(markers2vis4heatmap)/100)
    heig = 5+log2(length(markers2vis4heatmap)/10)
    wid = 7.5
  }else if (length(markers2vis4heatmap) > 75){
     sz = 4-log2(length(markers2vis4heatmap)/120);heig = 7;wid = 7
  }else{
     sz = 6-log2(length(markers2vis4heatmap)/80);heig = 7;wid = 7
  }
  if ( opt$style == "seurat" ){
    ggheat = Seurat::DoHeatmap( object = data_ob,
                        features = markers2vis4heatmap,
                        group.colors = colors2use,
                        group.by = opt$groupby, group.bar = T, label = F,draw.lines=F ) +
      ggplot2::theme(axis.text.y = ggplot2::element_text(size = sz,face = "bold")) +
      ggplot2::scale_fill_gradientn(colors = c("#406AA8", "white", "#D91216"))

  }else{
      ggcheat = OESingleCell::DoComplexHeatmap(
                  data_ob,
                  features = markers2vis4heatmap,
                  group.by = opt$groupby,
                  cell.annotation = extra_groups,
                  group.colors = as.list(group_colors),
                  group.order = opt$group_orerby,
                  col.split.by = opt$col_splitby,
                  x.size = opt$row_txtsize,
                  gene.marks = row_markers,
                  value.colors = circlize::colorRamp2(c(-1.5, 0, 1.5), value_colors),
                  column_title = NULL )
      ggheat <- ggplotify::as.ggplot(grid::grid.grabExpr(ComplexHeatmap::draw(ggheat, padding = grid::unit(c(2, 3, 2, 20), "mm"))))

  }
    OESingleCell::save_ggplots(file.path(output_dir, "topmarker_gene_heatmap"),
                              plot = ggheat, dpi = 300 , limitsize = F,width = wid, height = heig, bg="white")

    setwd(output_dir)
    print("Convert pdf to png...")
    system(" /data/software/ImageMagick/ImageMagick-v7.0.8-14/bin/convert  -verbose -density 800 -trim  topmarker_gene_heatmap.pdf  -quality 500  -flatten  topmarker_gene_heatmap.png ")
    quit()
}

# ======================== Subcmd: diff_heatmap ==================================

if ( "diff_heatmap" %in% args ){
  # prepare diff genelist
  if ( is.null( opt$diffGene)){
      stop("NO diffgene list is AVAILABLE!")
  }
  topn_markers = data.frame()
  diffGene_path = normalizePath(opt$diffGene)
  diffGene_name = gsub(".*/","",diffGene_path)
  if(grepl("-diff-",diffGene_name)){
      name = gsub("-diff-.*","",diffGene_name)
  }else if(grepl("-all_",diffGene_name)){
      name = gsub("-all_.*","",diffGene_name)
  }
  markers2vis = read.delim( opt$diffGene, sep="\t", header = T,quote="")
  markers2vis = subset(markers2vis,!grepl("^(mt-|Rps|Rpl|MT-|RPS|RPL)",markers2vis$gene))
  up = dplyr::filter(markers2vis,FoldChange > 1) %>% dplyr::arrange(desc(log2FoldChange ))  %>% dplyr::top_n(opt$topn,log2FoldChange )
  down = dplyr::filter(markers2vis,FoldChange < 1) %>% dplyr::arrange(log2FoldChange )  %>% dplyr::top_n(as.numeric(paste0("-",opt$topn)),log2FoldChange )
  topn_markers = rbind(up, down)
  write.table(topn_markers,file.path(output_dir,paste0("top", opt$topn, "_", name, "_genes.xls", collapse = "")),quote = F,row.names = FALSE,sep="\t")
  markers2vis4heatmap = unique(as.vector(topn_markers$gene))
  # readin rds
    data_ob = OESingleCell::ReadX(
             input = opt$input, informat = opt$informat,
             assays = assays, data.use = dataslots, # "data","scale.data"
             reductions = opt$reduct, graphs = FALSE, images = FALSE, # no graph object needed here
             verbose = FALSE)
 data_ob@meta.data[,opt$groupby]=as.vector(data_ob@meta.data[,opt$groupby])
  # scale data for markers

# if (nrow(data_ob[[assays]]@scale.data)!=nrow(data_ob[[assays]]@data)){
  data_ob<-Seurat::ScaleData(data_ob,
                           features = markers2vis4heatmap, ## 更改为只针对marker基因进行scale,以减小内存压力
                           verbose = T )
#                           }
  # color settings
  group_colors = unlist(strsplit(opt$group_colors, ",", perl = T))
  names(group_colors) = opt$groupby
  if (opt$groupby == "sampleid" || grepl("^group", opt$groupby)){
  color_schema = OESingleCell::SelectColors(palette =group_colors)
  nfacet <- length(unique(OESingleCell::colData(data_ob)[[opt$groupby]]))
  colors2use = color_schema[11:(10+nfacet)]
  names(colors2use)=unique(OESingleCell::colData(data_ob)[[opt$groupby]])
    }else{
          colors2use = OESingleCell::SelectColors(1:length(unique(OESingleCell::colData(data_ob)[[opt$groupby]])),palette= group_colors )
		  names(colors2use)=unique(OESingleCell::colData(data_ob)[[opt$groupby]])
    }
  #get subset of cells used col.name = col.name = or visualization if necessay
  if ( !is.null(opt$predicate) ){
    df = OESingleCell::colData(data_ob)
    desired_cells= subset(df, eval( parse(text=opt$predicate)))
    data_ob = data_ob[, rownames(desired_cells)]
  }

  # downsample to specified ratio in case of too many cells to plot
  cellmeta = OESingleCell::colData(data_ob)
  if ( !is.null(opt$sample_ratio) ){
      sampled_cellmeta = cellmeta %>% tibble::rownames_to_column() %>%
                         dplyr::group_by( .dots= opt$groupby ) %>%
                         dplyr::sample_frac( size = opt$sample_ratio,replace = F) %>%
                         tibble::column_to_rownames()
       data_ob = data_ob[, rownames(sampled_cellmeta)]
  }

  # visualize
  ggheat = Seurat::DoHeatmap( object = data_ob,
                        features = markers2vis4heatmap,
                        group.colors = colors2use,
                        group.by = opt$groupby, group.bar = T, label = F, draw.lines = F) +
      ggplot2::theme(axis.text.y = ggplot2::element_text(size = 6-log2(length(markers2vis4heatmap)/80),face = "bold"))+
      ggplot2::guides(fill = ggplot2::guide_colorbar( title.position = "top", order = 1)  ) +#, color = ggplot2::guide_legend(order = 2, override.aes = list(alpha = 1)))+
      ggplot2::scale_fill_gradientn(colors = c("#406AA8", "white", "#D91216"))
    OESingleCell::save_ggplots(file.path(output_dir, paste0("top", opt$topn, "_", name, "_heatmap", collapse = "")) ,
                      plot = ggheat, dpi = 300 , limitsize = F,width = 7, height = 7, bg="white")
    setwd(output_dir)
    print("Convert pdf to png...")
    system("for i in  `ls top*_heatmap.pdf`;do /data/software/ImageMagick/ImageMagick-v7.0.8-14/bin/convert  -verbose -density 500 -trim  $i  -quality 100  -flatten  ${i/.pdf/.png}  ;done")
    quit()
}

# ======================== Subcmd: elbowplot =================================

if ( "elbow" %in% args ){
  # read the specified assay and data slot in data object into memory
  # for visualization usually only "data" slot is loaded,which can save a lot of time and memory
  data_ob = OESingleCell::ReadX(
             input = opt$input, informat = opt$informat,
             assays = assays, data.use = dataslots, # "data","scale.data"
             reductions = opt$reduct, graphs = FALSE, images = FALSE, # no graph object needed here
             verbose = FALSE)

  #get subset of cells used col.name = col.name = or visualization if necessay
  if ( !is.null(opt$predicate) ){
    df = colData(data_ob)
    desired_cells= subset(df, eval( parse(text=opt$predicate)))
    data_ob = data_ob[, rownames(desired_cells)]
  }

  # to visulaize the metadata of each cell on the tsne plot
    ggelb = OESingleCell::ElbowPlot2(data_ob)
    OESingleCell::save_ggplots(file.path(output_dir,"Elbow_plot"),plot=ggelb, dpi = 600, bg="white")
    quit()
}

if ( "jackstraw" %in% args ){
  # read the specified assay and data slot in data object into memory
  # for visualization usually only "data" slot is loaded,which can save a lot of time and memory
  data_ob = OESingleCell::ReadX(
             input = opt$input, informat = opt$informat,
             assays = assays, data.use = dataslots, # "data","scale.data"
             reductions = opt$reduct, graphs = FALSE, images = FALSE, # no graph object needed here
             verbose = FALSE)

  #get subset of cells used col.name = col.name = or visualization if necessay
  if ( !is.null(opt$predicate) ){
    df = colData(data_ob)
    desired_cells= subset(df, eval( parse(text=opt$predicate)))
    data_ob = data_ob[, rownames(desired_cells)]
  }

  components2use = min( opt$components, ncol(Embeddings(data_ob[[opt$reduct]])))
  data_ob <- Seurat::JackStraw(data_ob , num.replicate = 100,
                         reduction = opt$reduct, dims = components2use)
  data_ob <- Seurat::ScoreJackStraw(data_ob, dims = components2use, reduction = opt$reduct)
  ggjack = Seurat::JackStrawPlot(object = data_ob, dims = 1:components2use)
  OESingleCell::save_ggplots(file.path(output_dir,"jackstraw_plot"),plot=ggjack, dpi = 600, bg="white")
  quit()
}


if ( "dimplot" %in% args ){
    # read the specified assay and data slot in data object into memory
    # for visualization usually only "data" slot is loaded,which can save a lot of time and memory
    data_ob = OESingleCell::ReadX(
               input = opt$input, informat = opt$informat,
               assays = assays, data.use = dataslots, # "data","scale.data"
               reductions = opt$reduct, graphs = FALSE, images = FALSE, # no graph object needed here
               verbose = FALSE)

    #get subset of cells used col.name = col.name = or visualization if necessay
    if ( !is.null(opt$predicate) ){
      df = colData(data_ob)
      desired_cells= subset(df, eval( parse(text=opt$predicate)))
      data_ob = data_ob[, rownames(desired_cells)]
    }

    if ( is.null( opt$groupby ) ){
      print("The groupping information is not specified. The ident will be used for plot")
      cellfeature2vis = "ident"
    }else{
      cellfeature2vis = unlist(strsplit(opt$groupby, ",", perl = T))
    }

    if ( !is.null( opt$splitby)  ){
      facetby = unlist( strsplit( opt$splitby, ",", perl =T ) )
    }

    cellmeta = OESingleCell::colData(data_ob)
    for (groupfactor in cellfeature2vis ){
      output_dir = file.path(output_dir, paste0( "visualize_cluster_by_", groupfactor, collapse = ""))
      if ( !is.null(facetby) ){
        for ( facetbyx in facetby ){
          nrow = ceiling(length(unique(cellmeta[[facetbyx]]))/2)
          nlevel = length(unique(cellmeta[[groupfactor]]))
          Seurat::Idents(data_ob) = groupfactor
          groupvis_split = DimPlot(object = data_ob,
                                   reduction = opt$reduct,
                                   pt.size = as.numeric(opt$ptsize),
                                   ncol = 2,
                                   group.by = groupfactor,
                                   split.by = facetbyx)+
            theme( plot.title = element_text(hjust = 0.5))
          groupvis_split = groupvis_split +
                  scale_colour_manual( values = OESingleCell::SelectColors(1:nlevel, palette = ),
                                       labels = sort(unique(Idents(data_ob)))
                                     )
          OESingleCell::save_ggplots(
            file.path(output_dir,paste0("splitby-",facetbyx, "_scatter_plot.pdf",collapse="")),
            plot = groupvis_split, height = 6*nrow, width = 14,
            to.pdf=TRUE, to.png=TRUE,limitsize = FALSE, bg="white" )
        }
      }else{
        if ( as.numeric(opt$dims) == 2 ){
          groupvis = DimPlot(object = data_ob,
                             dims = c(1,2),
                             reduction = opt$reduct,
                             pt.size = as.numeric(opt$ptsize),
                             group.by = groupfactor)+
            theme( plot.title = element_text(hjust = 0.5)) +
            scale_colour_manual( values = OESingleCell::SelectColors(nlevel:nlevel*2))
          ggsave(file.path(output_dir,paste0("groupby-",groupfactor,"_resolution",resolution,"_contrast_plot.pdf",collapse="")),
                 limitsize = FALSE, plot = groupvis, height = 10, width = 12, bg="white")
          ggsave(file.path(output_dir,paste0("groupby-",groupfactor,"_resolution",resolution,"_contrast_plot.png",collapse="")),
                 limitsize = FALSE, plot = groupvis, width = 15, height = 10, bg="white")
        }else{
          groupvis = SeuratPlotly::DimPlotly3d(data_ob, reduction= opt$reduct,
                                 pt_size = as.numeric(opt$ptsize),
                                 grouping_var = groupfactor,
                                 palette = "",
                                 plot_grid = F)
          htmlwidgets::saveWidget(groupvis, file = file.path(output_dir,paste0("groupby-",groupfactor,"_resolution",resolution,"_contrast_3D_plot.html",collapse="")))
        }
      }
    }

    quit()
}

# summarize the cell type composition in each sample and group
if ( "summarize" %in% args ){
  # read the specified assay and data slot in data object into memory
  # for visualization usually only "data" slot is loaded,which can save a lot of time and memory
  data_ob = OESingleCell::ReadX(
             input = opt$input, informat = opt$informat,
             assays = assays, data.use = dataslots, # "data","scale.data"
             reductions = opt$reduct, graphs = FALSE, images = FALSE, # no graph object needed here
             verbose = FALSE)

  #get subset of cells used col.name = col.name = or visualization if necessay
  if ( !is.null(opt$predicate) ){
    df = colData(data_ob)
    desired_cells= subset(df, eval( parse(text=opt$predicate)))
    data_ob = data_ob[, rownames(desired_cells)]
  }

  Seurat::Ident(data_ob) = opt$groupby
  DATA <- OESingleCell::FetchData(data_ob, vars= c("sampleid", opt$groupby) ) %>%
            dplyr::group_by( .dots= c("sampleid", opt$groupby)) %>%
            dplyr::summarize(count = n()) %>%
            dplyr::mutate(freq = (count / sum(count)) * 100)
  write.table(as.data.frame(DATA),
              file.path(output_dir,file="clust_cond_freq_info.xls"),
              sep="\t",col.names=T, row.names =F)
  # visulaize the summary statistics of cells clusters in each groupping factor
  clust_sum_all = OESingleCell::PlotAbundances(data_ob, prop.by = opt$groupby , group.by = "sampleid", method = "barplot",
                                 cols= OESingleCell::SelectColors(1:length(unique(Idents(data_ob))))
  )
  ggsave(file.path(output_dir,paste0("groupby-sampleid_resolution-",resolution,"_summary_plot.pdf",collapse="")),plot=clust_sum_all, bg="white")
  ggsave(file.path(output_dir,paste0("groupby-sampleid_resolution-",resolution,"_summary_plot.png",collapse="")),dpi=1000, plot = clust_sum_all, bg="white")
  data_ob = SetIdent(data_ob, value = "sampleid")
  clust_sum_all2 = OESingleCell:PlotAbundances(data_ob, prop.by = "sampleid", group.by = opt$groupby, method = "barplot",
                                  cols= OESingleCell::SelectColors(1:length(unique(Idents(data_ob))))
  )
  ggsave(file.path(output_dir,paste0("groupby-",opt$groupby,"_resolution-",resolution,"_summary_plot.pdf",collapse="")),plot=clust_sum_all2, bg="white")
  ggsave(file.path(output_dir,paste0("groupby-",opt$groupby,"_resolution-",resolution,"_summary_plot.png",collapse="")),dpi=1000, plot = clust_sum_all2, bg="white")

  DATA <- as.data.frame( data_ob@meta.data[,c(opt$groups, opt$propby)] ) %>%
    group_by( .dots= c(opt$groups, opt$proby)) %>%
    dplyr::summarize(count = n()) %>%
    dplyr::mutate(freq = (count / sum(count)) * 100)
  write.table(as.data.frame(DATA),
              file.path(output_dir,file="clust_cond_freq_info.xls"),
              sep="\t",col.names=T, row.names =F)
  cell.meta = OESingleCell::colData(data_ob)
  clust_sum_all = OESingleCell::PlotAbundances(data_ob,
                                               prop.by = opt$propby,
                                               group.by = opt$groups,
                                               split.by = facetby,
                                               method = opt$plot,
                                               ncol = ifelse(opt$plot=="pie",4,1),
                                               cols= OESingleCell::SelectColors(1:length(unique(cell.meta[[opt$propby]])))
  )
  ggsave(file.path(output_dir,paste0("groupby-",opt$groups,"_resolution-",resolution,"summary_plot.pdf",collapse="")),plot=clust_sum_all, bg="white")
  ggsave(file.path(output_dir,paste0("groupby-",opt$groups,"_resolution-",resolution,"summary_plot.png",collapse="")),dpi=1000, plot = clust_sum_all, bg="white")
  quit()
}


# visulaize the feature of cell on the dimension reduction plot, the feature can be anything pulled by FetechData
if ( "featureplot" %in% args ){

  if ( is.null( opt$markers ) & is.null(opt$extraGene)){
      stop("NO marker genes is AVAILABLE!")
  }

  # prepare markers to be visualized
  topn_markers = data.frame()
  if ( !is.null(opt$markers) ){
      markers2vis = read.table( opt$markers, sep="\t", header = T )
      topn_markers  = markers2vis %>%
          dplyr::group_by(cluster) %>%
          # dplyr::arrange(p_val, desc(avg_log2FC)) %>%
          dplyr::arrange(desc(gene_diff)) %>%
          dplyr::top_n(opt$topn, wt = !!rlang::sym(opt$topby) ) %>%
          dplyr::arrange(cluster) %>%
          dplyr::mutate(folder_suffix = paste0("cluster",cluster)) %>%
          dplyr::select(cluster,gene,folder_suffix)
  }

  # add extra customized genes if existis
  if ( !is.null(opt$extraGene) ){
    extra_gene = read.table(opt$extraGene, sep="\t", header = T)
    if (dim(extra_gene)[2] == 1 && colnames(extra_gene)[1] == "gene"){colnames(extra_gene)[1]="extra"}
    formated_extra_gene = as.data.frame(tidyr::gather(extra_gene,key = "cluster",value = "GENE"))
    match = OESingleCell::CaseMatch(search = as.vector(formated_extra_gene$GENE),match = rownames(data_ob))
    formated_extra_gene = formated_extra_gene %>%
                          dplyr::filter(GENE %in% names(match)) %>%
                          dplyr::mutate(gene = match,folder_suffix = cluster) %>%
                          dplyr::select(cluster, gene,folder_suffix)
    topn_markers = rbind(topn_markers, formated_extra_gene)
  }

  feature_list = unique(as.vector(topn_markers$gene))
  nrow = ceiling(length(topn_markers2vis)/2)

  # read the specified assay and data slot in data object into memory
  # for visualization usually only "data" slot is loaded,which can save a lot of time and memory
  data_ob = OESingleCell::ReadX(
             input = opt$input, informat = opt$informat,
             assays = assays, data.use = dataslots, # "data","scale.data"
             reductions = opt$reduct, graphs = FALSE, images = FALSE, # no graph object needed here
             verbose = FALSE)

  #get subset of cells used col.name = col.name = or visualization if necessay
  if ( !is.null(opt$predicate) ){
    df = colData(data_ob)
    desired_cells= subset(df, eval( parse(text=opt$predicate)))
    data_ob = data_ob[, rownames(desired_cells)]
  }

  suppressMessages({
    ggfeatures = Seurat::FeaturePlot(data_ob,reduction= opt$reduct,
                            features = feature_list, split.by = opt$facetby,
                            keep.scale = "all",
                            max.cutoff = 'q99',
                            order = T,
                            pt.size = as.numeric(opt$ptsize)) &
                  ggplot2::scale_color_gradientn(colours = continious_colors) &
                  theme(legend.position = "right",
                        legend.margin = margin(0,0.5,0,0, unit = "cm"),
                        plot.margin = margin(0, 0, 0, 0.1, unit = "cm"),
                        plot.title = element_text(hjust = 0.5) )
  })
  OESingleCell::save_ggplots(
      file.path(output_dir, "marker_gene_featureplot"),
      width =  4*ifelse(is.null(splitby),yes = 2, no =length(unique(cellmeta[[splitby]]))),
      height = 3*ifelse(is.null(splitby),
                        yes = ceiling(length(topn_markers2vis)/2),
                        no  = length(topn_markers2vis)),
      plot = ggfeatures, dpi = 300 ,limitsize = F, bg="white" )

  quit()
}

if  ( "multifeature" %in% args ){
  # read the specified assay and data slot in data object into memory
  # for visualization usually only "data" slot is loaded,which can save a lot of time and memory
  data_ob = OESingleCell::ReadX(
             input = opt$input, informat = opt$informat,
             assays = assays, data.use = dataslots, # "data","scale.data"
             reductions = opt$reduct, graphs = FALSE, images = FALSE, # no graph object needed here
             verbose = FALSE)

  #get subset of cells used col.name = col.name = or visualization if necessay
  if ( !is.null(opt$predicate) ){
    df = colData(data_ob)
    desired_cells= subset(df, eval( parse(text=opt$predicate)))
    data_ob = data_ob[, rownames(desired_cells)]
  }

  if ( !is.null(opt$feature1) & !is.null(opt$feature2) ){
    ggscater = FeatureScatter(data_ob, feature1 = opt$feature1, slot = opt$slot,
                              feature2 = opt$feature2, group.by = opt$groupby )
    OESingleCell::save_ggplots(file.path(output_dir, paste0(feature1,"_VS_",feature2, "_visulazation")),
                               dpi = 600, plot=ggscater, bg="white")
  }
  quit()
}

if ( "summarize" %in% args ){
  DATA <- OESingleCell::colData(data_ob)[,c(opt$groups, opt$propby)]  %>%
              dplyr::group_by( .dots= c(opt$groups, opt$proby)) %>%
              dplyr::summarize(count = n()) %>%
              dplyr::mutate(freq = (count / sum(count)) * 100)
  write.table(as.data.frame(DATA), file.path(output_dir,file="clust_cond_freq_info.xls"),
              sep="\t",col.names=T, row.names =F)
  clust_sum_all = OESingleCell::PlotAbundances(data_ob,
                                               prop.by = opt$propby,
                                               group.by = opt$groups,
                                               split.by = opt$facetby,
                                               method = opt$plot,
                                               ncol = ifelse(opt$plot=="pie",4,1),
                                               cols= OESingleCell::SelectColors(1:length(unique(data_ob@meta.data[,opt$propby])))
  )
  ggsave(file.path(output_dir,paste0("groupby-",opt$groups,"_resolution-",resolution,"summary_plot.pdf",collapse="")),plot=clust_sum_all, bg="white")
  ggsave(file.path(output_dir,paste0("groupby-",opt$groups,"_resolution-",resolution,"summary_plot.png",collapse="")),dpi=1000, plot = clust_sum_all, bg="white")
  quit()
}

if ( "vlnplot" %in% args ){
  # prepare markers to be visualized
  topn_markers = data.frame()
  if ( !is.null(opt$markers) ){
      markers2vis = read.table( opt$markers, sep="\t", header = T )
      topn_markers  = markers2vis %>%
          dplyr::group_by(cluster) %>%
          # dplyr::arrange(p_val, desc(avg_log2FC)) %>%
          dplyr::arrange(desc(gene_diff)) %>%
          dplyr::top_n(opt$topn, wt = !!rlang::sym(opt$topby) ) %>%
          dplyr::arrange(cluster) %>%
          dplyr::mutate(folder_suffix = paste0("cluster",cluster)) %>%
          dplyr::select(cluster,gene,folder_suffix)
  }

  # add extra customized genes if existis
  if ( !is.null(opt$extraGene) ){
    extra_gene = read.table(opt$extraGene, sep="\t", header = T)
    if (dim(extra_gene)[2] == 1 && colnames(extra_gene)[1] == "gene"){colnames(extra_gene)[1]="extra"}
    formated_extra_gene = as.data.frame(tidyr::gather(extra_gene,key = "cluster",value = "GENE"))
    match = OESingleCell::CaseMatch(search = as.vector(formated_extra_gene$GENE),match = rownames(data_ob))
    formated_extra_gene = formated_extra_gene %>%
                          dplyr::filter(GENE %in% names(match)) %>%
                          dplyr::mutate(gene = match,folder_suffix = cluster) %>%
                          dplyr::select(cluster, gene,folder_suffix)
    topn_markers = rbind(topn_markers, formated_extra_gene)
  }
  # Draws a violin plot of single cell data (gene expression, metrics, PC scores, etc.)
  for ( clusterx in unique(topn_markers$folder_suffix) ){
    topn = topn_markers %>%
      dplyr::filter( folder_suffix == clusterx) %>%
      dplyr::select(cluster,gene,folder_suffix)
    topn_markers2vis = as.vector(topn$gene)

    path4vis = file.path(root_dir,paste0("markers_vis4",clusterx,collapse = ""))
    if ( file.exists( path4vis ) ){
        output_dir = path4vis
    }else{
        output_dir = path4vis
        dir.create(output_dir)
    }

    colors2use = OESingleCell::SelectColors(1:length(unique(OESingleCell::colData(data_ob)[[groupby]])))
    gs = lapply(topn_markers2vis,
                function(x) Seurat::VlnPlot(data_ob, features = x, cols = colors2use,
                                    pt.size = opt$pointsize, alpha = opt$alpha2use,
                                    group.by = groupby, split.by = splitby,
                                    split.plot = as.logical(opt$dodge)
                                    )+
                labs(title = "",y = x) +
                theme(legend.position = "none",
                # panel.spacing = unit(.05, "lines"),
                axis.title.x = element_text(size = 0),
                axis.title.y = element_text(size = 12),
                axis.text.y=element_text(size = 8)))
    pdf(file.path(output_dir,paste0("marker_gene_violin_plot.pdf", collapse = "_")),
                    width = 8, height = length(topn_markers2vis)*2)
    grid.arrange(grobs = gs, ncol=1)
    dev.off()
    png(file.path(output_dir,paste0("marker_gene_violin_plot.png", collapse = "_")),
                    width = 800,height = length(topn_markers2vis)*120)
    grid.arrange(grobs = gs, ncol=1)
    dev.off()
  }
}


if ( "dotplot" %in% args ){
  # prepare markers to be visualized
  topn_markers = data.frame()
  if ( !is.null(opt$markers) ){
      markers2vis = read.table( opt$markers, sep="\t", header = T )
      topn_markers  = markers2vis %>%
          dplyr::group_by(cluster) %>%
          # dplyr::arrange(p_val, desc(avg_log2FC)) %>%
          dplyr::arrange(desc(gene_diff)) %>%
          dplyr::top_n(opt$topn, wt = !!rlang::sym(opt$topby) ) %>%
          dplyr::arrange(cluster) %>%
          dplyr::mutate(folder_suffix = paste0("cluster",cluster)) %>%
          dplyr::select(cluster,gene,folder_suffix)
  }

  # add extra customized genes if existis
  if ( !is.null(opt$extraGene) ){
    extra_gene = read.table(opt$extraGene, sep="\t", header = T)
    if (dim(extra_gene)[2] == 1 && colnames(extra_gene)[1] == "gene"){colnames(extra_gene)[1]="extra"}
    formated_extra_gene = as.data.frame(tidyr::gather(extra_gene,key = "cluster",value = "GENE"))
    match = OESingleCell::CaseMatch(search = as.vector(formated_extra_gene$GENE),match = rownames(data_ob))
    formated_extra_gene = formated_extra_gene %>%
                          dplyr::filter(GENE %in% names(match)) %>%
                          dplyr::mutate(gene = match,folder_suffix = cluster) %>%
                          dplyr::select(cluster, gene,folder_suffix)
    topn_markers = rbind(topn_markers, formated_extra_gene)
  }
  # data_ob = Seurat::SetIdent( data_ob, value = groupby )
  Seurat::Idents(data_ob) = groupby
  markers2vis4dotplot = unique(as.vector(topn_markers$gene))
  ggdot = Seurat::DotPlot(object = data_ob, features = markers2vis4dotplot ) + RotatedAxis()
  OESingleCell::save_ggplots(file.path(output_dir,"marker_gene_dotplot.png"),
                            plot = ggdot, dpi = 300 ,limitsize = F, bg="white")
}

if ( "ridgeplot" %in% args ){
  # prepare markers to be visualized
  topn_markers = data.frame()
  if ( !is.null(opt$markers) ){
      markers2vis = read.table( opt$markers, sep="\t", header = T )
      topn_markers  = markers2vis %>%
          dplyr::group_by(cluster) %>%
          # dplyr::arrange(p_val, desc(avg_log2FC)) %>%
          dplyr::arrange(desc(gene_diff)) %>%
          dplyr::top_n(opt$topn, wt = !!rlang::sym(opt$topby) ) %>%
          dplyr::arrange(cluster) %>%
          dplyr::mutate(folder_suffix = paste0("cluster",cluster)) %>%
          dplyr::select(cluster,gene,folder_suffix)
  }

  # add extra customized genes if existis
  if ( !is.null(opt$extraGene) ){
    extra_gene = read.table(opt$extraGene, sep="\t", header = T)
    if (dim(extra_gene)[2] == 1 && colnames(extra_gene)[1] == "gene"){colnames(extra_gene)[1]="extra"}
    formated_extra_gene = as.data.frame(tidyr::gather(extra_gene,key = "cluster",value = "GENE"))
    match = OESingleCell::CaseMatch(search = as.vector(formated_extra_gene$GENE),match = rownames(data_ob))
    formated_extra_gene = formated_extra_gene %>%
                          dplyr::filter(GENE %in% names(match)) %>%
                          dplyr::mutate(gene = match,folder_suffix = cluster) %>%
                          dplyr::select(cluster, gene,folder_suffix)
    topn_markers = rbind(topn_markers, formated_extra_gene)
  }
    cellmeta = OESingleCell::colData(data_ob)
    # set color for visualizarion
    colors2use = OESingleCell::SelectColors(1:length(unique(cellmeta[[groupby]])), palette = opt$palette)
    for ( clusterx in unique(topn_markers$folder_suffix) ){
        topn = topn_markers %>% filter( folder_suffix == clusterx) %>% select(cluster,gene,folder_suffix)
        topn_markers2vis = as.vector(topn$gene)

        path4vis = file.path(root_dir,paste0("markers_vis4",clusterx,collapse = ""))
        if ( file.exists( path4vis ) ){
            output_dir = path4vis
        }else{
            output_dir = path4vis
            dir.create(output_dir)
        }
        # data_ob = Seurat::SetIdent( data_ob, value = groupby )
        Seurat::Idents(data_ob) = groupby
        ggridge = Seurat::RidgePlot( object = data_ob, features = topn_markers2vis,
                    cols = colors2use, nCol = 3)
        OESingleCell::save_ggplots(file.path(output_dir,"marker_gene_ridgeplot"),
                                  plot = ggridge, dpi = 300 ,limitsize = F, bg="white")
    }
}

if ( "stackvln" %in% args ){
    # prepare markers to be visualized
    topn_markers = data.frame()
    if ( !is.null(opt$markers) ){
        markers2vis = read.table( opt$markers, sep="\t", header = T )
        topn_markers  = markers2vis %>%
            dplyr::group_by(cluster) %>%
            # dplyr::arrange(p_val, desc(avg_log2FC)) %>%
            dplyr::arrange(desc(gene_diff)) %>%
            dplyr::top_n(opt$topn, wt = !!rlang::sym(opt$topby) ) %>%
            dplyr::arrange(cluster) %>%
            dplyr::mutate(folder_suffix = paste0("cluster",cluster)) %>%
            dplyr::select(cluster,gene,folder_suffix)
    }

    # add extra customized genes if existis
    if ( !is.null(opt$extraGene) ){
      extra_gene = read.table(opt$extraGene, sep="\t", header = T)
      if (dim(extra_gene)[2] == 1 && colnames(extra_gene)[1] == "gene"){colnames(extra_gene)[1]="extra"}
      formated_extra_gene = as.data.frame(tidyr::gather(extra_gene,key = "cluster",value = "GENE"))
      match = OESingleCell::CaseMatch(search = as.vector(formated_extra_gene$GENE),match = rownames(data_ob))
      formated_extra_gene = formated_extra_gene %>%
                            dplyr::filter(GENE %in% names(match)) %>%
                            dplyr::mutate(gene = match,folder_suffix = cluster) %>%
                            dplyr::select(cluster, gene,folder_suffix)
      topn_markers = rbind(topn_markers, formated_extra_gene)
    }
    cellmeta = OESingleCell::colData(data_ob)

    # set color for visualizarion
    colors2use = OESingleCell::SelectColors(1:length(unique(cellmeta[[opt$groupby]])), palette = opt$palette)
    gg_stackvln = Seurat::VlnPlot( data_ob, features = topn_markers2vis, group.by = opt$groupby,
                                  split.plot = as.logical(opt$dodge),
                                  cols = colors2use, split.by = opt$splitby, pt_size = opt$pointsize,
                                  flip = opt$flip, stack = T, fill.by = groupby)
    OESingleCell::save_ggplots(file.path(output_dir,"marker_gene_stacked_violin_plot"),
                            plot = ggdot, dpi = 300 ,
                            height = length(topn_markers2vis) * 0.6, width = length(unique(cellmeta[[groupby]]))*0.5+1,
                            limitsize = F, bg="white")
    quit()
}

# =============== Subcmd: coefficient heatmap =========
if ( "coefficient" %in% args ){
  groupby = opt$groupby
  # read the specified assay and data slot in data object into memory
  data_ob = OESingleCell::ReadX(
               input = opt$input, informat = opt$informat,
               assays = assays,
               data.use = dataslots, # "data"
               reductions = opt$reduct, # only the used reduction results needed
               graphs = FALSE, # no graph object needed here
               images = FALSE, verbose = FALSE)

  # subset test data object
  if ( !is.null(opt$predicate) ){
      df = OESingleCell::colData(data_ob)
      desired_cells= subset(df, eval( parse(text=opt$predicate)))
      data_ob = data_ob[, rownames(desired_cells)]
  }

  # export the gene expression matrix
  groupby_data = vector()
  for (i in names(table(data_ob[[groupby]]))  ) {
      sub_ob = data_ob[, rownames(data_ob@meta.data[which(data_ob@meta.data[,groupby] %in% i),])]
      normalized_data = as.matrix(sub_ob[[opt$assay]]@data)
      meta.data = sub_ob@meta.data %>% tibble::rownames_to_column(var = "id")
      groupby_data = cbind(groupby_data,rowMeans(normalized_data))
  }
  colnames(groupby_data) = names(table(data_ob[[groupby]]))
  data = tibble::rownames_to_column(as.data.frame(groupby_data),var="GeneID")
  write.table(data, file.path(output_dir,paste0("normalized_data_groupby_",groupby,".xls")),quote = F, row.names = F, sep = "\t")

  # sampleid_clusters
  if (groupby == "clusters") {
        id1="sampleid"
        id2="clusters"
        groupby2 = paste0(id1,"_",id2)
        data_ob@meta.data[,groupby2] = paste0(data_ob@meta.data[[id1]],"_",data_ob@meta.data[[id2]])
        levels = paste0(rep(levels(factor(data_ob@meta.data[[id1]])),each=length(unique(data_ob@meta.data[,id2]))),"_",sort(unique(data_ob@meta.data[[id2]])))
        data_ob@meta.data[,groupby2]  =factor(data_ob@meta.data[,groupby2] ,levels=levels)
        groupby_data2 = vector()
        groupby_data2_names = vector()
        for (i in names(table(data_ob[[groupby2]]))  ) {
            if (length(which(data_ob@meta.data[,groupby2] %in% i)) !=0) {
                sub_ob = data_ob[, rownames(data_ob@meta.data[which(data_ob@meta.data[,groupby2] %in% i),])]
                normalized_data = as.matrix(sub_ob[[opt$assay]]@data)
                meta.data = sub_ob@meta.data %>% tibble::rownames_to_column(var = "id")
                groupby_data2 = cbind(groupby_data2,rowMeans(normalized_data))
                groupby_data2_names = c(groupby_data2_names,i)
            }
        }
        colnames(groupby_data2) = groupby_data2_names
        data = tibble::rownames_to_column(as.data.frame(groupby_data2),var="GeneID")
        write.table(data, file.path(output_dir,paste0("normalized_data_groupby_",groupby2,".xls")),quote = F, row.names = F, sep = "\t")           
  }


  # calculate the correlation and visulize by heatmap
  colnames(groupby_data) = gsub('^',paste0(groupby,"_"),colnames(groupby_data))
  matrix<-cor(groupby_data,method="pearson")
  wid<-5+1.5*log2(length(colnames(data)))
  hig<-5+1.5*log2(length(colnames(data)))
  coefficient = pheatmap::pheatmap(matrix,
                       display_numbers = F,
                       border_color = "white",
                       scale = "none",
                       fontsize_number=(10.0+0.0001*log2(length(colnames(data)))),
                       number_format = "%.1f",
                       fontsize_row = (10.0+0.0001*log2(length(colnames(data)))),
                       fontsize_col = (10.0+0.0001*log2(length(colnames(data)))),
                       number_color="black",
                       angle_col=45)
  OESingleCell::save_ggplots(file.path(output_dir,"coefficient_heatmap"),
                          plot = coefficient, dpi = 300 ,
                          height = hig, width = wid, limitsize = F, bg="white")

  quit()
}

if ( "density" %in% args ){
  # TO DO
  print("NOT IMPLIMENTED YET!")
  quit()
}



#============================sub_monocleplots=====================================
if ( "monocle_vis" %in% args ){
  suppressPackageStartupMessages( library("monocle") )
  suppressPackageStartupMessages(library("dplyr"))
  suppressPackageStartupMessages(library("pheatmap"))
  suppressPackageStartupMessages(library("plyr"))
  suppressPackageStartupMessages(library("igraph"))
  suppressPackageStartupMessages(library("reshape2"))
  suppressPackageStartupMessages(library("viridis")) 
  suppressPackageStartupMessages(library("tibble"))

  plot_genes_in_pseudotime_line <- function (cds_subset, min_expr = NULL, cell_size = 0.75, nrow = NULL,
      ncol = 1, panel_order = NULL, color_by = "State", trend_formula = paste0("~sm.ns(Pseudotime, df=3) * ", opt$groupby),
      label_by_short_name = TRUE, relative_expr = TRUE, vertical_jitter = NULL,
      horizontal_jitter = NULL){
      f_id <- NA
      Cell <- NA
      if (cds_subset@expressionFamily@vfamily %in% c("negbinomial",
          "negbinomial.size")) {
          integer_expression <- TRUE
      }
      else {
          integer_expression <- FALSE
          relative_expr <- TRUE
      }
      if (integer_expression) {
          cds_exprs <- exprs(cds_subset)
          if (relative_expr) {
              if (is.null(sizeFactors(cds_subset))) {
                  stop("Error: to call this function with relative_expr=TRUE, you must call estimateSizeFactors() first")
              }
              cds_exprs <- Matrix::t(Matrix::t(cds_exprs)/sizeFactors(cds_subset))
          }
          cds_exprs <- reshape2::melt(round(as.matrix(cds_exprs)))
      }
      else {
          cds_exprs <- reshape2::melt(as.matrix(exprs(cds_subset)))
      }
      if (is.null(min_expr)) {
          min_expr <- cds_subset@lowerDetectionLimit
      }
      colnames(cds_exprs) <- c("f_id", "Cell", "expression")
      cds_pData <- pData(cds_subset)
      cds_fData <- fData(cds_subset)
      cds_exprs <- merge(cds_exprs, cds_fData, by.x = "f_id", by.y = "row.names")
      cds_exprs <- merge(cds_exprs, cds_pData, by.x = "Cell", by.y = "row.names")
      if (integer_expression) {
          cds_exprs$adjusted_expression <- cds_exprs$expression
      }
      else {
          cds_exprs$adjusted_expression <- log10(cds_exprs$expression)
      }
      if (label_by_short_name == TRUE) {
          if (is.null(cds_exprs$gene_short_name) == FALSE) {
              cds_exprs$feature_label <- as.character(cds_exprs$gene_short_name)
              cds_exprs$feature_label[is.na(cds_exprs$feature_label)] <- cds_exprs$f_id
          }
          else {
              cds_exprs$feature_label <- cds_exprs$f_id
          }
      }
      else {
          cds_exprs$feature_label <- cds_exprs$f_id
      }
      cds_exprs$f_id <- as.character(cds_exprs$f_id)
      cds_exprs$feature_label <- factor(cds_exprs$feature_label)
      new_data <- data.frame(Pseudotime = pData(cds_subset)$Pseudotime)
      model_expectation <- genSmoothCurves(cds_subset, cores = 1,
          trend_formula = trend_formula, relative_expr = T, new_data = new_data)
      colnames(model_expectation) <- colnames(cds_subset)
      expectation <- ddply(cds_exprs, .(f_id, Cell), function(x) data.frame(expectation = model_expectation[x$f_id,
          x$Cell]))
      cds_exprs <- merge(cds_exprs, expectation)
      cds_exprs$expression[cds_exprs$expression < min_expr] <- min_expr
      cds_exprs$expectation[cds_exprs$expectation < min_expr] <- min_expr
      if (is.null(panel_order) == FALSE) {
          cds_exprs$feature_label <- factor(cds_exprs$feature_label,
              levels = panel_order)
      }
      q <- ggplot(aes(Pseudotime, expression), data = cds_exprs) +
                        scale_y_log10() +
                        geom_line(aes_string(x = 'Pseudotime', y = 'expectation',color = color_by),size = 1, data = cds_exprs)+
                        expand_limits(y = min_expr)+
                        facet_wrap(~feature_label, nrow = nrow, ncol = ncol, scales = "free_y")+
                        ylab("Expression") + xlab("Pseudotime") +
                        theme_bw() +
                        theme(panel.grid=element_blank(), panel.border=element_blank(),axis.line = element_line(size=1,colour="black"))
      q
  }

  # change heatmap annotation from Cluster to Module
  plot_pseudotime_heatmap <- function(cds_subset, cluster_rows = TRUE, hclust_method = "ward.D2",
                                      num_clusters = 6, hmcols = NULL, add_annotation_row = NULL,
                                      add_annotation_col = NULL, show_rownames = FALSE, use_gene_short_name = TRUE,
                                      norm_method = c("log", "vstExprs"), scale_max = 3, scale_min = -3,
                                      trend_formula = "~sm.ns(Pseudotime, df=3)", return_heatmap = FALSE,
                                      cores = 1) {
      num_clusters <- min(num_clusters, nrow(cds_subset))
      pseudocount <- 1
      newdata <- data.frame(Pseudotime = seq(min(pData(cds_subset)$Pseudotime),
          max(pData(cds_subset)$Pseudotime),
          length.out = 100
      ))
      m <- genSmoothCurves(cds_subset,
          cores = cores, trend_formula = trend_formula,
          relative_expr = T, new_data = newdata
      )
      m <- m[!apply(m, 1, sum) == 0, ]
      norm_method <- match.arg(norm_method)
      if (norm_method == "vstExprs" && is.null(cds_subset@dispFitInfo[["blind"]]$disp_func) ==
          FALSE) {
          m <- vstExprs(cds_subset, expr_matrix = m)
      } else if (norm_method == "log") {
          m <- log10(m + pseudocount)
      }
      m <- m[!apply(m, 1, sd) == 0, ]
      m <- Matrix::t(scale(Matrix::t(m), center = TRUE))
      m <- m[is.na(row.names(m)) == FALSE, ]
      m[is.nan(m)] <- 0
      m[m > scale_max] <- scale_max
      m[m < scale_min] <- scale_min
      heatmap_matrix <- m
      row_dist <- as.dist((1 - cor(Matrix::t(heatmap_matrix))) / 2)
      row_dist[is.na(row_dist)] <- 1
      if (is.null(hmcols)) {
          bks <- seq(-3.1, 3.1, by = 0.1)
          hmcols <- monocle:::blue2green2red(length(bks) - 1)
      } else {
          bks <- seq(-3.1, 3.1, length.out = length(hmcols))
      }
      ph <- pheatmap(heatmap_matrix,
          useRaster = T, cluster_cols = FALSE,
          cluster_rows = cluster_rows, show_rownames = F, show_colnames = F,
          clustering_distance_rows = row_dist, clustering_method = hclust_method,
          cutree_rows = num_clusters, silent = TRUE, filename = NA,
          breaks = bks, border_color = NA, color = hmcols
      )
      if (cluster_rows) {
          annotation_row <- data.frame(Module = factor(cutree(
              ph$tree_row, #
              num_clusters
          )))
      } else {
          annotation_row <- NULL
      }
      if (!is.null(add_annotation_row)) {
          old_colnames_length <- ncol(annotation_row)
          annotation_row <- cbind(annotation_row, add_annotation_row[row.names(annotation_row), ])
          colnames(annotation_row)[(old_colnames_length + 1):ncol(annotation_row)] <- colnames(add_annotation_row)
      }
      if (!is.null(add_annotation_col)) {
          if (nrow(add_annotation_col) != 100) {
              stop("add_annotation_col should have only 100 rows (check genSmoothCurves before you supply the annotation data)!")
          }
          annotation_col <- add_annotation_col
      } else {
          annotation_col <- NA
      }
      module_colors <- scales::dscale(factor(1:num_clusters), scales::hue_pal(l = 75))
      names(module_colors) <- 1:num_clusters
      annotation_colors <- list( Module = module_colors)
      if (use_gene_short_name == TRUE) {
          if (is.null(fData(cds_subset)$gene_short_name) == FALSE) {
              feature_label <- as.character(fData(cds_subset)[
                  row.names(heatmap_matrix),
                  "gene_short_name"
              ])
              feature_label[is.na(feature_label)] <- row.names(heatmap_matrix)
              row_ann_labels <- as.character(fData(cds_subset)[
                  row.names(annotation_row),
                  "gene_short_name"
              ])
              row_ann_labels[is.na(row_ann_labels)] <- row.names(annotation_row)
          } else {
              feature_label <- row.names(heatmap_matrix)
              row_ann_labels <- row.names(annotation_row)
          }
      } else {
          feature_label <- row.names(heatmap_matrix)
          if (!is.null(annotation_row)) {
                row_ann_labels <- row.names(annotation_row)
            }
      }
      row.names(heatmap_matrix) <- feature_label
      if (!is.null(annotation_row)) {
            row.names(annotation_row) <- row_ann_labels
        }
      colnames(heatmap_matrix) <- c(1:ncol(heatmap_matrix))
      ph_res <- pheatmap(heatmap_matrix[, ],
          useRaster = T, cluster_cols = FALSE,
          cluster_rows = cluster_rows, show_rownames = show_rownames,
          show_colnames = F, clustering_distance_rows = row_dist,
          clustering_method = hclust_method, cutree_rows = num_clusters,
          annotation_row = annotation_row, annotation_col = annotation_col, 
          annotation_colors = annotation_colors, treeheight_row = 20, breaks = bks,
          fontsize = 6, color = hmcols, border_color = NA, silent = TRUE, filename = NA
      )
      grid::grid.rect(gp = grid::gpar("fill", col = NA))
      grid::grid.draw(ph_res$gtable)
      if (return_heatmap) {
          return(list(
              heatmap_matrix = heatmap_matrix, ph = ph, row_dist = row_dist,
              hmcols = hmcols, annotation_row = annotation_row, bks = bks,
              annotation_col = annotation_col, annotation_colors = annotation_colors, ph_res = ph_res
          ))
      }
  }



  plot_genes_branched_heatmap <- function(cds_subset, branch_point = 1, branch_states = NULL,
                                          branch_labels = c("Cell fate 1", "Cell fate 2"), cluster_rows = TRUE,
                                          hclust_method = "ward.D2", num_clusters = 6, hmcols = NULL,
                                          branch_colors = c("#979797", "#F05662", "#7990C8"), add_annotation_row = NULL,
                                          add_annotation_col = NULL, show_rownames = FALSE, use_gene_short_name = TRUE,
                                          scale_max = 3, scale_min = -3, norm_method = c("log", "vstExprs"),
                                          trend_formula = "~sm.ns(Pseudotime, df=3) * Branch", return_heatmap = FALSE,
                                          cores = 1, ...) {
      cds <- NA
      new_cds <- buildBranchCellDataSet(cds_subset,
          branch_states = branch_states,
          branch_point = branch_point, progenitor_method = "duplicate",
          ...
      )
      new_cds@dispFitInfo <- cds_subset@dispFitInfo
      if (is.null(branch_states)) {
          progenitor_state <- subset(pData(cds_subset), Pseudotime ==
              0)[, "State"]
          branch_states <- setdiff(pData(cds_subset)$State, progenitor_state)
      }
      col_gap_ind <- 101
      newdataA <- data.frame(
          Pseudotime = seq(0, 100, length.out = 100),
          Branch = as.factor(unique(as.character(pData(new_cds)$Branch))[1])
      )
      newdataB <- data.frame(
          Pseudotime = seq(0, 100, length.out = 100),
          Branch = as.factor(unique(as.character(pData(new_cds)$Branch))[2])
      )
      BranchAB_exprs <- genSmoothCurves(new_cds[, ],
          cores = cores,
          trend_formula = trend_formula, relative_expr = T, new_data = rbind(
              newdataA,
              newdataB
          )
      )
      BranchA_exprs <- BranchAB_exprs[, 1:100]
      BranchB_exprs <- BranchAB_exprs[, 101:200]
      common_ancestor_cells <- row.names(pData(new_cds)[pData(new_cds)$State ==
          setdiff(pData(new_cds)$State, branch_states), ])
      BranchP_num <- (100 - floor(max(pData(new_cds)[
          common_ancestor_cells,
          "Pseudotime"
      ])))
      BranchA_num <- floor(max(pData(new_cds)[
          common_ancestor_cells,
          "Pseudotime"
      ]))
      BranchB_num <- BranchA_num
      norm_method <- match.arg(norm_method)
      if (norm_method == "vstExprs") {
          BranchA_exprs <- vstExprs(new_cds, expr_matrix = BranchA_exprs)
          BranchB_exprs <- vstExprs(new_cds, expr_matrix = BranchB_exprs)
      } else if (norm_method == "log") {
          BranchA_exprs <- log10(BranchA_exprs + 1)
          BranchB_exprs <- log10(BranchB_exprs + 1)
      }
      heatmap_matrix <- cbind(
          BranchA_exprs[, (col_gap_ind - 1):1],
          BranchB_exprs
      )
      heatmap_matrix <- heatmap_matrix[!apply(
          heatmap_matrix, 1,
          sd
      ) == 0, ]
      heatmap_matrix <- Matrix::t(scale(Matrix::t(heatmap_matrix),
          center = TRUE
      ))
      heatmap_matrix <- heatmap_matrix[is.na(row.names(heatmap_matrix)) ==
          FALSE, ]
      heatmap_matrix[is.nan(heatmap_matrix)] <- 0
      heatmap_matrix[heatmap_matrix > scale_max] <- scale_max
      heatmap_matrix[heatmap_matrix < scale_min] <- scale_min
      heatmap_matrix_ori <- heatmap_matrix
      heatmap_matrix <- heatmap_matrix[is.finite(heatmap_matrix[
          ,
          1
      ]) & is.finite(heatmap_matrix[, col_gap_ind]), ]
      row_dist <- as.dist((1 - cor(Matrix::t(heatmap_matrix))) / 2)
      row_dist[is.na(row_dist)] <- 1
      exp_rng <- range(heatmap_matrix)
      bks <- seq(exp_rng[1] - 0.1, exp_rng[2] + 0.1, by = 0.1)
      if (is.null(hmcols)) {
          hmcols <- monocle:::blue2green2red(length(bks) - 1)
      }
      ph <- pheatmap(heatmap_matrix,
          useRaster = T, cluster_cols = FALSE,
          cluster_rows = TRUE, show_rownames = F, show_colnames = F,
          clustering_distance_rows = row_dist, clustering_method = hclust_method,
          cutree_rows = num_clusters, silent = TRUE, filename = NA,
          breaks = bks, color = hmcols
      )
      annotation_row <- data.frame(Module = factor(cutree(
          ph$tree_row, #
          num_clusters
      )))
      if (!is.null(add_annotation_row)) {
          annotation_row <- cbind(annotation_row, add_annotation_row[row.names(annotation_row), ])
      }
      colnames(heatmap_matrix) <- c(1:ncol(heatmap_matrix))
      annotation_col <- data.frame(
          row.names = c(1:ncol(heatmap_matrix)),
          `Cell Type` = c(rep(branch_labels[1], BranchA_num), rep(
              "Pre-branch",
              2 * BranchP_num
          ), rep(branch_labels[2], BranchB_num))
      )
      colnames(annotation_col) <- "Cell Type"
      if (!is.null(add_annotation_col)) {
          annotation_col <- cbind(annotation_col, add_annotation_col[fData(cds[row.names(annotation_col), ])$gene_short_name, 1])
      }
      names(branch_colors) <- c(
          "Pre-branch", branch_labels[1],
          branch_labels[2]
      )
      module_colors <- scales::dscale(factor(1:num_clusters), scales::hue_pal(l = 75))
      names(module_colors) <- 1:num_clusters
      annotation_colors <- list(`Cell Type` = branch_colors, Module = module_colors)
      names(annotation_colors$`Cell Type`) <- c("Pre-branch", branch_labels)
      if (use_gene_short_name == TRUE) {
          if (is.null(fData(cds_subset)$gene_short_name) == FALSE) {
              feature_label <- as.character(fData(cds_subset)[
                  row.names(heatmap_matrix),
                  "gene_short_name"
              ])
              feature_label[is.na(feature_label)] <- row.names(heatmap_matrix)
              row_ann_labels <- as.character(fData(cds_subset)[
                  row.names(annotation_row),
                  "gene_short_name"
              ])
              row_ann_labels[is.na(row_ann_labels)] <- row.names(annotation_row)
          } else {
              feature_label <- row.names(heatmap_matrix)
              row_ann_labels <- row.names(annotation_row)
          }
      } else {
          feature_label <- row.names(heatmap_matrix)
          row_ann_labels <- row.names(annotation_row)
      }
      row.names(heatmap_matrix) <- feature_label
      row.names(annotation_row) <- row_ann_labels
      ph_res <- pheatmap(heatmap_matrix[, ],
          useRaster = T, cluster_cols = FALSE,
          cluster_rows = TRUE, show_rownames = show_rownames, show_colnames = F,
          clustering_distance_rows = row_dist, clustering_method = hclust_method,
          cutree_rows = num_clusters, annotation_row = annotation_row,
          annotation_col = annotation_col, annotation_colors = annotation_colors,
          gaps_col = col_gap_ind, treeheight_row = 20, breaks = bks,
          fontsize = 6, color = hmcols, border_color = NA, silent = TRUE
      )
      grid::grid.rect(gp = grid::gpar("fill", col = NA))
      grid::grid.draw(ph_res$gtable)
      if (return_heatmap) {
          return(list(
              BranchA_exprs = BranchA_exprs, BranchB_exprs = BranchB_exprs,
              heatmap_matrix = heatmap_matrix, heatmap_matrix_ori = heatmap_matrix_ori,
              ph = ph, col_gap_ind = col_gap_ind, row_dist = row_dist,
              hmcols = hmcols, annotation_colors = annotation_colors, bks = bks,
              annotation_row = annotation_row, annotation_col = annotation_col,
              ph_res = ph_res
          ))
      }
  }

  # change width of the pseudotime evolutionary tree from 0.1 to 0.05
  # adding param width = 0.05 to geom_jitter
  plot_complex_cell_trajectory <- function(cds,
                                          x = 1,
                                          y = 2,
                                          root_states = NULL,
                                          color_by = "State",
                                          show_tree = TRUE,
                                          show_backbone = TRUE,
                                          backbone_color = "black",
                                          markers = NULL,
                                          show_cell_names = FALSE,
                                          cell_size = 1.5,
                                          cell_link_size = 0.75,
                                          cell_name_size = 2,
                                          show_branch_points = TRUE,
                                          ...) {
      gene_short_name <- NA
      sample_name <- NA
      data_dim_1 <- NA
      data_dim_2 <- NA

      # TODO: need to validate cds as ready for this plot (need mst, pseudotime, etc)
      lib_info_with_pseudo <- pData(cds)

      if (is.null(cds@dim_reduce_type)) {
          stop("Error: dimensionality not yet reduced. Please call reduceDimension() before calling this function.")
      }

      if (cds@dim_reduce_type == "ICA") {
          reduced_dim_coords <- reducedDimS(cds)
      } else if (cds@dim_reduce_type %in% c("SimplePPT", "DDRTree", "SGL-tree")) {
          reduced_dim_coords <- reducedDimK(cds)
          closest_vertex <- cds@auxOrderingData[["DDRTree"]]$pr_graph_cell_proj_closest_vertex
      } else {
          stop("Error: unrecognized dimensionality reduction method.")
      }

      if (is.null(reduced_dim_coords)) {
          stop("You must first call reduceDimension() before using this function")
      }

      dp_mst <- minSpanningTree(cds)


      if (is.null(root_states)) {
          if (is.null(lib_info_with_pseudo$Pseudotime)) {
              root_cell <- row.names(lib_info_with_pseudo)[degree(dp_mst) == 1][1]
          } else {
                root_cell <- row.names(subset(lib_info_with_pseudo, Pseudotime == 0))
            }

          if (cds@dim_reduce_type != "ICA") {
                root_cell <- V(dp_mst)$name[cds@auxOrderingData$DDRTree$pr_graph_cell_proj_closest_vertex[root_cell, ]]
            }
      } else {
          candidate_root_cells <- row.names(subset(pData(cds), State %in% root_states))
          if (cds@dim_reduce_type == "ICA") {
              root_cell <- candidate_root_cells[which(degree(dp_mst, candidate_root_cells) == 1)]
          } else {
              Y_candidate_root_cells <- V(dp_mst)$name[cds@auxOrderingData$DDRTree$pr_graph_cell_proj_closest_vertex[candidate_root_cells, ]]
              root_cell <- Y_candidate_root_cells[which(degree(dp_mst, Y_candidate_root_cells) == 1)]
          }
      }

      tree_coords <- layout_as_tree(dp_mst, root = root_cell)

      ica_space_df <- data.frame(tree_coords)
      row.names(ica_space_df) <- colnames(reduced_dim_coords)
      colnames(ica_space_df) <- c("prin_graph_dim_1", "prin_graph_dim_2")

      ica_space_df$sample_name <- row.names(ica_space_df)


      if (is.null(dp_mst)) {
          stop("You must first call orderCells() before using this function")
      }

      edge_list <- as.data.frame(get.edgelist(dp_mst))
      colnames(edge_list) <- c("source", "target")

      edge_df <- merge(ica_space_df, edge_list, by.x = "sample_name", by.y = "source", all = TRUE)
      edge_df <- plyr::rename(edge_df, c("prin_graph_dim_1" = "source_prin_graph_dim_1", "prin_graph_dim_2" = "source_prin_graph_dim_2"))
      edge_df <- merge(edge_df, ica_space_df[, c("sample_name", "prin_graph_dim_1", "prin_graph_dim_2")], by.x = "target", by.y = "sample_name", all = TRUE)
      edge_df <- plyr::rename(edge_df, c("prin_graph_dim_1" = "target_prin_graph_dim_1", "prin_graph_dim_2" = "target_prin_graph_dim_2"))

      if (cds@dim_reduce_type == "ICA") {
          S_matrix <- tree_coords[, ] # colnames(cds)
      } else if (cds@dim_reduce_type %in% c("DDRTree", "SimplePPT", "SGL-tree")) {
          S_matrix <- tree_coords[closest_vertex, ]
          closest_vertex <- cds@auxOrderingData[["DDRTree"]]$pr_graph_cell_proj_closest_vertex
      }

      data_df <- data.frame(S_matrix)
      row.names(data_df) <- colnames(reducedDimS(cds))
      colnames(data_df) <- c("data_dim_1", "data_dim_2")
      data_df$sample_name <- row.names(data_df)
      data_df <- merge(data_df, lib_info_with_pseudo, by.x = "sample_name", by.y = "row.names")

      markers_exprs <- NULL
      if (is.null(markers) == FALSE) {
          markers_fData <- subset(fData(cds), gene_short_name %in% markers)
          if (nrow(markers_fData) >= 1) {
              markers_exprs <- reshape2::melt(as.matrix(exprs(cds[row.names(markers_fData), ])))
              colnames(markers_exprs)[1:2] <- c("feature_id", "cell_id")
              markers_exprs <- merge(markers_exprs, markers_fData, by.x = "feature_id", by.y = "row.names")
              # print (head( markers_exprs[is.na(markers_exprs$gene_short_name) == FALSE,]))
              markers_exprs$feature_label <- as.character(markers_exprs$gene_short_name)
              markers_exprs$feature_label[is.na(markers_exprs$feature_label)] <- markers_exprs$Var1
          }
      }
      if (is.null(markers_exprs) == FALSE && nrow(markers_exprs) > 0) {
          data_df <- merge(data_df, markers_exprs, by.x = "sample_name", by.y = "cell_id")
          # print (head(edge_df))
          g <- ggplot(data = data_df, aes(x = data_dim_1, y = data_dim_2, I(cell_size))) +
              facet_wrap(~feature_label)
      } else {
          g <- ggplot(data = data_df, aes(x = data_dim_1, y = data_dim_2))
      }
      if (show_tree) {
          g <- g + geom_segment(aes_string(x = "source_prin_graph_dim_1", y = "source_prin_graph_dim_2", xend = "target_prin_graph_dim_1", yend = "target_prin_graph_dim_2"), size = cell_link_size, linetype = "solid", na.rm = TRUE, data = edge_df)
      }

      # FIXME: setting size here overrides the marker expression funtionality.
      # Don't do it!
      if (is.null(markers_exprs) == FALSE && nrow(markers_exprs) > 0) {
          if (class(data_df[, color_by]) == "numeric") {
              g <- g + geom_jitter(aes_string(color = paste0("log10(", color_by, " + 0.1)")), size = I(cell_size), na.rm = TRUE, height = 5, width = 0.03) +
                  scale_color_viridis(name = paste0("log10(", color_by, ")"), ...)
          } else {
              g <- g + geom_jitter(aes_string(color = color_by), size = I(cell_size), na.rm = TRUE, height = 5, width = 0.03)
          }
      } else {
          if (class(data_df[, color_by]) == "numeric") {
              g <- g + geom_jitter(aes_string(color = paste0("log10(", color_by, " + 0.1)")), size = I(cell_size), na.rm = TRUE, height = 5, width = 0.03) +
                  scale_color_viridis(name = paste0("log10(", color_by, " + 0.1)"), ...)
          } else {
              g <- g + geom_jitter(aes_string(color = color_by), size = I(cell_size), na.rm = TRUE, height = 5, width = 0.03)
          }
      }

      if (show_branch_points && cds@dim_reduce_type == "DDRTree") {
          mst_branch_nodes <- cds@auxOrderingData[[cds@dim_reduce_type]]$branch_points
          branch_point_df <- subset(edge_df, sample_name %in% mst_branch_nodes)[, c("sample_name", "source_prin_graph_dim_1", "source_prin_graph_dim_2")]
          branch_point_df$branch_point_idx <- match(branch_point_df$sample_name, mst_branch_nodes)
          branch_point_df <- branch_point_df[!duplicated(branch_point_df$branch_point_idx), ]

          g <- g + geom_point(aes_string(x = "source_prin_graph_dim_1", y = "source_prin_graph_dim_2"),
              size = 2 * cell_size, na.rm = TRUE, data = branch_point_df
          ) +
              geom_text(aes_string(x = "source_prin_graph_dim_1", y = "source_prin_graph_dim_2", label = "branch_point_idx"),
                  size = 1.5 * cell_size, color = "white", na.rm = TRUE, data = branch_point_df
              )
      }
      if (show_cell_names) {
          g <- g + geom_text(aes(label = sample_name), size = cell_name_size)
      }
      g <- g +
          # scale_color_brewer(palette="Set1") +
          theme(strip.background = element_rect(colour = "white", fill = "white")) +
          theme(panel.border = element_blank()) +
          # theme(axis.line.x = element_line(size=0.25, color="black")) +
          # theme(axis.line.y = element_line(size=0.25, color="black")) +
          theme(panel.grid.minor.x = element_blank(), panel.grid.minor.y = element_blank()) +
          theme(panel.grid.major.x = element_blank(), panel.grid.major.y = element_blank()) +
          theme(panel.background = element_rect(fill = "white")) +
          theme(legend.key = element_blank()) +
          xlab("") +
          ylab("") +
          theme(legend.position = "top", legend.key.height = grid::unit(0.35, "in")) +
          # guides(color = guide_legend(label.position = "top")) +
          theme(legend.key = element_blank()) +
          theme(panel.background = element_rect(fill = "white")) +
          theme(
              line = element_blank(),
              axis.text.x = element_blank(),
              axis.text.y = element_blank(),
              axis.ticks = element_blank()
          )
      g
  }


  plot_tf_auc_in_pseudotime <- function(cds_subset, min_expr = NULL, cell_size = 0.75, nrow = NULL,
                                        ncol = 1, panel_order = NULL, color_by = "State", trend_formula = "~ sm.ns(Pseudotime, df=3)",
                                        label_by_short_name = TRUE, relative_expr = TRUE, vertical_jitter = NULL,
                                        horizontal_jitter = NULL) {
      f_id <- NA
      Cell <- NA
      integer_expression <- FALSE
      relative_expr <- FALSE

      if (integer_expression) {
          cds_exprs <- exprs(cds_subset)
          if (relative_expr) {
              if (is.null(sizeFactors(cds_subset))) {
                  stop("Error: to call this function with relative_expr=TRUE, you must call estimateSizeFactors() first")
              }
              cds_exprs <- Matrix::t(Matrix::t(cds_exprs) / sizeFactors(cds_subset))
          }
          cds_exprs <- reshape2::melt(round(as.matrix(cds_exprs)))
      } else {
          cds_exprs <- reshape2::melt(as.matrix(exprs(cds_subset)))
      }
      if (is.null(min_expr)) {
          min_expr <- cds_subset@lowerDetectionLimit
      }
      colnames(cds_exprs) <- c("f_id", "Cell", "expression")
      cds_pData <- pData(cds_subset)
      cds_fData <- fData(cds_subset)
      # cds_exprs <- merge(cds_exprs, cds_fData, by.x = "f_id", by.y = "row.names") ## 注释掉
      cds_exprs <- merge(cds_exprs, cds_pData, by.x = "Cell", by.y = "row.names")
      if (integer_expression) {
          cds_exprs$adjusted_expression <- cds_exprs$expression
      } else {
          cds_exprs$adjusted_expression <- log10(cds_exprs$expression)
      }
      if (label_by_short_name == TRUE) {
          if (is.null(cds_exprs$gene_short_name) == FALSE) {
              cds_exprs$feature_label <- as.character(cds_exprs$gene_short_name)
              cds_exprs$feature_label[is.na(cds_exprs$feature_label)] <- cds_exprs$f_id
          } else {
              cds_exprs$feature_label <- cds_exprs$f_id
          }
      } else {
          cds_exprs$feature_label <- cds_exprs$f_id
      }
      cds_exprs$f_id <- as.character(cds_exprs$f_id)
      cds_exprs$feature_label <- factor(cds_exprs$feature_label)
      new_data <- data.frame(Pseudotime = pData(cds_subset)$Pseudotime)
      model_expectation <- genSmoothCurves(cds_subset,
          cores = 1,
          trend_formula = trend_formula, relative_expr = T, new_data = new_data
      )
      colnames(model_expectation) <- colnames(cds_subset)
      rownames(model_expectation) <- rownames(cds_subset) ### 增加
      expectation <- ddply(cds_exprs, .(f_id, Cell), function(x) {
          data.frame(expectation = model_expectation[
              x$f_id,
              x$Cell
          ])
      })
      cds_exprs <- merge(cds_exprs, expectation)
      # cds_exprs$expression[cds_exprs$expression < min_expr] <- min_expr
      # cds_exprs$expectation[cds_exprs$expectation < min_expr] <- min_expr

      if (is.null(panel_order) == FALSE) {
          cds_exprs$feature_label <- factor(cds_exprs$feature_label,
              levels = panel_order
          )
      }
      q <- ggplot(aes(Pseudotime, expression), data = cds_exprs)
      if (is.null(color_by) == FALSE) {
          q <- q + geom_point(aes_string(color = color_by),
              size = I(cell_size),
              position = position_jitter(horizontal_jitter, vertical_jitter)
          )
      } else {
          q <- q + geom_point(size = I(cell_size), position = position_jitter(
              horizontal_jitter,
              vertical_jitter
          ))
      }
      # q <- q + geom_line(aes(x = Pseudotime, y = expectation),
      #    data = cds_exprs)

      q <- q + geom_smooth(method = loess, formula = y ~ x, se = FALSE, col = "black", size = 0.5)
      q <- q + scale_y_log10() + facet_wrap(~feature_label,
          nrow = nrow,
          ncol = ncol, scales = "free_y"
      )

      # if (min_expr < 1) {
      #     q <- q + expand_limits(y = c(min_expr, 1))
      # }
      if (relative_expr) {
          q <- q + ylab("Relative Expression")
      } else {
          q <- q + ylab("AUC")
      }
      q <- q + xlab("Pseudo-time")
      q <- q + monocle:::monocle_theme_opts() ### 增加调用包
      q
  }

  CustomCol2 <- function(n) {
      my_palette <- c(
          "#7fc97f", "#beaed4", "#fdc086", "#386cb0", "#f0027f", "#a34e3b", "#666666", "#1b9e77", "#d95f02", "#7570b3",
          "#d01b2a", "#43acde", "#efbd25", "#492d73", "#cd4275", "#2f8400", "#d9d73b", "#aed4ff", "#ecb9e5", "#813139",
          "#743fd2", "#434b7e", "#e6908e", "#214a00", "#ef6100", "#7d9974", "#e63c66", "#cf48c7", "#ffe40a", "#a76e93",
          "#d9874a", "#adc64a", "#5466df", "#d544a1", "#54d665", "#5e99c7", "#006874", "#d2ad2c", "#b5d7a5", "#9e8442",
          "#4e1737", "#e482a7", "#6f451d", "#2ccfe4", "#ae6174", "#a666be", "#a32b2b", "#ffff99", "#3fdacb", "#bf5b17"
      )
      return(my_palette[n])
  }
  get_colors <- function(object, groupby){
                  if(paste0(groupby,"_col") %in% colnames(pData(object))){
                      groupby_col = paste0(groupby,"_col")
                      nlevel_list = levels(factor(pData(object)[,groupby]))
                      tmp_df <- unique(pData(object)[c(groupby, groupby_col)])
                      groupby_pal <- as.vector(tmp_df[,groupby_col])
                      names(groupby_pal) <-  as.vector(tmp_df[,groupby])
                      groupby_pal = as.list(groupby_pal)
                      user_color_pal = unlist(groupby_pal[nlevel_list])
                  }else if(groupby =="clusters"){
                      nlevel <- sort(unique(pData(object)[,groupby]))
                      user_color_pal = CustomCol2(nlevel)
                  }else {
                      nlevel = length(unique(pData(object)[,groupby]))
                      user_color_pal = CustomCol2(1:nlevel)
                  }
                  return(user_color_pal)
                }

  # =================================================================================
  # parse the command line parameters
  # =================================================================================
  if (is.null(opt$output)) {
      print("NO OUTPUT PATH SUPPLIED,current directory will be used!")
      output_dir <- getwd()
  } else {
      output_dir <- opt$output
      if (!file.exists(output_dir)) {
          dir.create(output_dir, recursive = T)
      }
  }

  if (is.null(opt$vismethod)) {
      print("NO vismethod is provided. Only cell_trajectory_color_by_Pseudotime will be ploted if --root is specified.")
      vismethods <- NULL
  } else if (opt$vismethod == "all") {
      vismethods <- c("heatmap", "expressplot", "trajectoryplot", "treeplot", "ridgeplot", "module")
  } else {
      vismethods <- unlist(strsplit(opt$vismethod, ","))
  }


  if (is.null(opt$showname)) {
      if (!is.null(opt$genelist)) {
          if (opt$genelist == "ordering") {
              showname <- FALSE
          } else {
              showname <- TRUE
          }
      }
  } else {
      showname <- opt$showname
  }

  # =================================================================================
  # main workflow
  # =================================================================================
  gbm_cds <- readRDS(opt$input)

  ## change the root state
  if (!is.null(opt$root)) {
      gbm_cds <- orderCells(gbm_cds, root_state = opt$root) # root_state =分支编
      p <- plot_cell_trajectory(gbm_cds, color_by = "Pseudotime", cell_size = opt$pointsize, show_branch_points = opt$show_branch) + scale_colour_viridis_c(option = "inferno")
      if (opt$show_branch) {
          ggsave(file.path(output_dir, "cell_trajectory_color_by_Pseudotime_show_branch_points.pdf"), plot = p, bg="white")
          ggsave(file.path(output_dir, "cell_trajectory_color_by_Pseudotime_show_branch_points.png"), plot = p, dpi = 300, bg="white")
      } else {
          ggsave(file.path(output_dir, "cell_trajectory_color_by_Pseudotime.pdf"), plot = p, bg="white")
          ggsave(file.path(output_dir, "cell_trajectory_color_by_Pseudotime.png"), plot = p, dpi = 300, bg="white")
          saveRDS(gbm_cds, opt$input)
      }
  }

  ## subset the gbm_cds if genelist id provided
  if (!is.null(opt$genelist)) {
      if (opt$genelist == "ordering") {
          genes <- as.factor(subset(gbm_cds@featureData@data, use_for_ordering == TRUE)$gene_short_name)
          to_be_tested <- row.names(subset(fData(gbm_cds), gene_short_name %in% levels(genes)))
      } else {
          gene <- read.delim(opt$genelist, sep = "\t")
          if (dim(gene)[2] > 1) {
              up <- filter(gene, FoldChange > 1) %>%
                  arrange(desc(log2FoldChange)) %>%
                  top_n(opt$topn, log2FoldChange) %>%
                  select(gene)
              down <- filter(gene, FoldChange < 1) %>%
                  arrange(log2FoldChange) %>%
                  top_n(as.numeric(paste0("-", opt$topn)), log2FoldChange) %>%
                  select(gene)
              if (opt$toptype == "up") {
                  gene <- up
              } else if (opt$toptype == "down") {
                  gene <- down
              } else {
                  gene <- rbind(up, down)
              }
          }
          gene[, 1] <- factor(as.character(gene[, 1]))
          to_be_tested <- Seurat::CaseMatch(search = levels(gene[, 1]), match = row.names(fData(gbm_cds)))
      }
      gbm_cds <- gbm_cds[to_be_tested, ]
  }


  # =================================================================================
  # visualization
  # =================================================================================
  for (vismethod in vismethods) {
      if (vismethod == "bin") {
          md=pData(gbm_cds)
          if( ! opt$groupby %in% colnames(md) ){
              stop("Column ",opt$groupby," not found in data")
          }
          md$Pseudotime_bin =  floor(gbm_cds$Pseudotime*(opt$nbin-1)/max(gbm_cds$Pseudotime))+1
          xaxis="Pseudotime_bin"
          propby=opt$groupby
          field4emeta = colnames(md)
          cluster_ids <- md[, propby]
          sample_ids <- md[, xaxis]
          counts <- table(cluster_ids, sample_ids)
          df <- reshape2::melt(t(round(t(counts)/colSums(counts) * 100, 2)), 
              varnames = c(propby, xaxis), value.name = "freq")
          df[, xaxis] = factor(df[, xaxis])
          df[, propby] = factor(df[, propby])
          # plot
          p = ggplot(df) + geom_bar(aes_string(y = "freq", 
              x = xaxis, fill = propby), position = "stack", stat = "identity" ,width=1) + 
              scale_fill_manual(values = CustomCol2(1:50)) + 
              scale_y_continuous(expand = c(0, 0), labels = seq(0, 100, 25)) + 
              labs(x = paste0("Pseudotime (",opt$nbin,"bins)"), y = "Cells per bin[%]") + 
              theme_bw() + 
              theme(panel.grid.minor = element_blank(), 
                  panel.grid.major = element_blank(), strip.background = element_rect(fill = NA, 
                  color = NA), panel.border = element_blank(), axis.ticks.x = element_blank(), 
                  axis.text = element_text(color = "black"), axis.text.x = element_blank())
          ggsave(file.path(output_dir, paste0("Proportion_of_cells_in_pseudotime_bins_by_",propby,".pdf")), plot = p, bg="white")
          ggsave(file.path(output_dir, paste0("Proportion_of_cells_in_pseudotime_bins_by_",propby,".png")), plot = p, bg="white")
    }
      if (vismethod == "heatmap") {
          if (is.null(opt$anno)) {
              stop("Please provide Annotation file with --anno parameter.")
          } else {
              annotation <- opt$anno
          }
          if (is.null(opt$clusters)) {
              print("The number of clusters for the heatmap,the default will be used.")
              clusters_num <- 4
          } else {
              clusters_num <- opt$clusters
          }

          if (is.null(opt$branchpoint)) {
              print("NO branchpoint is provided, the heatmap without branchtime will be plotted.")
              branchpoint <- NULL
          } else {
              branchpoint <- opt$branchpoint
          }
          if (is.null(branchpoint)) { # heatmap without branchtime
              heatmap <- plot_pseudotime_heatmap(gbm_cds, cores = opt$ncores, cluster_rows = T, num_clusters = clusters_num, show_rownames = showname, return_heatmap = T)
              ggsave(file.path(output_dir, "pseudotime_heatmap.pdf"), plot = heatmap$ph_res, bg="white")
              ggsave(file.path(output_dir, "pseudotime_heatmap.png"), plot = heatmap$ph_res, dpi = 300, bg="white")
              gene_clusters <- cutree(heatmap$ph_res$tree_row, k = clusters_num)
          } else { # heatmap with branchtime
              new_cds <- buildBranchCellDataSet(gbm_cds, branch_point = branchpoint, progenitor_method = "duplicate")
              # cell_fate1
              cell_fate1 <- unique(pData(new_cds)[which(pData(new_cds)$Branch == unique(pData(new_cds)$Branch)[1]), ]$State)
              # cell_fate2
              cell_fate2 <- unique(pData(new_cds)[which(pData(new_cds)$Branch == unique(pData(new_cds)$Branch)[2]), ]$State)
        cell_fate1_label=levels(pData(new_cds)[which(pData(new_cds)$Branch == unique(pData(new_cds)$Branch)[1]), ]$State)[which(table(pData(new_cds)[which(pData(new_cds)$Branch == unique(pData(new_cds)$Branch)[1]), ]$State) > table(pData(new_cds)[which(pData(new_cds)$Branch == unique(pData(new_cds)$Branch)[2]), ]$State))]
              cell_fate2_label=levels(pData(new_cds)[which(pData(new_cds)$Branch == unique(pData(new_cds)$Branch)[2]), ]$State)[which(table(pData(new_cds)[which(pData(new_cds)$Branch == unique(pData(new_cds)$Branch)[2]), ]$State) > table(pData(new_cds)[which(pData(new_cds)$Branch == unique(pData(new_cds)$Branch)[1]), ]$State))]
              branch_labels <- c(paste("State", paste(sort(cell_fate1_label), collapse = "-")), paste("State", paste(sort(cell_fate2_label), collapse = "-")))
              #branch_labels <- c(paste("State", paste(sort(setdiff(cell_fate1, cell_fate2)), collapse = "-")), paste("State", paste(sort(setdiff(cell_fate2, cell_fate1)), collapse = "-")))
              branch_heatmap <- plot_genes_branched_heatmap(gbm_cds, branch_point = branchpoint, cores = opt$ncores, cluster_rows = T, num_clusters = clusters_num, use_gene_short_name = T, show_rownames = showname, branch_labels = branch_labels, return_heatmap = T)
              ggsave(file.path(output_dir, "pseudotime_heatmap_branchtime.pdf"), plot = branch_heatmap$ph_res, bg="white")
              ggsave(file.path(output_dir, "pseudotime_heatmap_branchtime.png"), plot = branch_heatmap$ph_res, dpi = 300, bg="white")
              gene_clusters <- cutree(branch_heatmap$ph_res$tree_row, k = clusters_num)
          }
          ### annotation
          gene_clustering <- data.frame(gene_clusters)
          gene_clustering[, 1] <- as.character(gene_clustering[, 1])
          colnames(gene_clustering) <- "gene_module"
          if (opt$genelist == "ordering") {
              ord_info <- featureData(gbm_cds)@data %>%
                  filter(use_for_ordering == "TRUE") %>%
                  dplyr::select(gene_short_name, vst.variance.standardized, pval, qval) #%>%
                  # tibble::column_to_rownames(var = "gene_short_name")
              if (is.null(branchpoint)) {
          newOrder <- ord_info[heatmap$ph_res$tree_row$order,]
        }else{
          newOrder <- ord_info[branch_heatmap$ph_res$tree_row$order,]
        }
        gene_inter <- intersect(rownames(newOrder),rownames(gene_clustering))
        ord_info <- ord_info[gene_inter, ]
        gene_clustering <- gene_clustering[gene_inter,1,drop=F]
        gene_clustering <- cbind(gene_clustering, ord_info)
          }
          gene_clustering <- gene_clustering %>% tibble::rownames_to_column(var = "gene")
          colnames(gene_clustering)<- gsub("pval","p-value",colnames(gene_clustering))
          colnames(gene_clustering)<- gsub("qval","q-value",colnames(gene_clustering))
          anno <- read.delim(annotation, stringsAsFactors = F, sep = "\t", quote = "")
          gene_clustering <- left_join(gene_clustering, anno, by = c("gene" = "id"))
          gene_clustering[is.na(gene_clustering)] <- "--"
          write.table(gene_clustering, file.path(output_dir, "pseudotime_heatmap_gene_module_anno.xls"), sep = "\t", quote = F, row.names = F)
      }

      if (vismethod == "expressplot") {
          for (i in seq(1, length(to_be_tested), 10)) {
              j <- min(i + 9, length(to_be_tested))
              to_be_tested_sub <- to_be_tested[i:j]
              cds_subset <- gbm_cds[to_be_tested_sub, ]
              user_color_pal = get_colors(cds_subset, opt$groupby)
              if (is.null(opt$branchpoint)) {
                  print("NO branchpoint is provided, the expressplot without branchtime will be plotted.")
                  branchpoint <- NULL
              } else {
                  branchpoint <- opt$branchpoint
              }
              if (is.null(branchpoint)) { # expressplot without branchtime
                  p <- plot_genes_in_pseudotime(cds_subset, color_by = opt$groupby, cell_size = opt$pointsize, ncol = opt$numcol) + scale_colour_manual(values = user_color_pal) + guides(colour = guide_legend(override.aes = list(size = 1.5)))
                  ggsave(file.path(output_dir, paste0("pseudotime_gene_express_", basename(opt$genelist), ifelse(i == 1, "", -ceiling(i / 10)), ".pdf")), height = if(length(to_be_tested_sub) == 1) 7 else if(length(to_be_tested) == 2) 3 else ceiling(length(to_be_tested_sub) / opt$numcol) * 2, bg="white")
                  ggsave(file.path(output_dir, paste0("pseudotime_gene_express_", basename(opt$genelist), ifelse(i == 1, "", -ceiling(i / 10)), ".png")), height = if(length(to_be_tested_sub) == 1) 7 else if(length(to_be_tested) == 2) 3 else ceiling(length(to_be_tested_sub) / opt$numcol) * 2, dpi = 1000, bg="white")
              } else { # expressplot with branchtime
                  new_cds <- buildBranchCellDataSet(cds_subset, branch_point = branchpoint, progenitor_method = "duplicate")
                  # cell_fate1
                  cell_fate1 <- unique(pData(new_cds)[which(pData(new_cds)$Branch == unique(pData(new_cds)$Branch)[1]), ]$State)
                  # cell_fate2
                  cell_fate2 <- unique(pData(new_cds)[which(pData(new_cds)$Branch == unique(pData(new_cds)$Branch)[2]), ]$State)
                  branch_labels <- c(paste("State", paste(sort(setdiff(cell_fate1, cell_fate2)), collapse = "-")), paste("State", paste(sort(setdiff(cell_fate2, cell_fate1)), collapse = "-")))
                  p <- plot_genes_branched_pseudotime(cds_subset, color_by = opt$groupby, branch_point = branchpoint, cell_size = opt$pointsize, ncol = opt$numcol, branch_labels = branch_labels) + scale_colour_manual(values = user_color_pal) + guides(colour = guide_legend(override.aes = list(size = 1.5)))
                  ggsave(file.path(output_dir, paste0("pseudotime_gene_express_branchtime", ifelse(i == 1, "", -ceiling(i / 10)), ".pdf")), height = ifelse(length(to_be_tested) == 2, 3, ceiling(length(to_be_tested_sub) / opt$numcol) * 2), bg="white")
                  ggsave(file.path(output_dir, paste0("pseudotime_gene_express_branchtime", ifelse(i == 1, "", -ceiling(i / 10)), ".png")), height = ifelse(length(to_be_tested) == 2, 3, ceiling(length(to_be_tested_sub) / opt$numcol) * 2), dpi = 1000, bg="white")
              }
          }
      }

      if ( vismethod == "expressplot_line" ){
          for( i in seq(1, length(to_be_tested), 10) ){
              j = min(i+9, length(to_be_tested))
              to_be_tested_sub = to_be_tested[i:j]
              cds_subset <- gbm_cds[to_be_tested_sub,]
              user_color_pal = get_colors(cds_subset, opt$groupby)
              # expressplot without branchtime
              p = plot_genes_in_pseudotime_line(cds_subset, color_by= opt$groupby ,cell_size = opt$pointsize , ncol = opt$numcol) + scale_colour_manual( values = user_color_pal) + guides(colour = guide_legend(override.aes = list(size=1.5))) 
              ggsave(file.path(output_dir, paste0("pseudotime_gene_express_line_",basename(opt$genelist),ifelse(i==1, "", -ceiling(i/10)), ".pdf")), height = ifelse( length(to_be_tested_sub)==1, 7, ceiling(length(to_be_tested_sub)/opt$numcol)*2 ), bg="white" )
              ggsave(file.path(output_dir, paste0("pseudotime_gene_express_line_",basename(opt$genelist),ifelse(i==1, "", -ceiling(i/10)), ".png")), height = ifelse( length(to_be_tested_sub)==1, 7, ceiling(length(to_be_tested_sub)/opt$numcol)*2 ), dpi = 300, bg="white")
          }
      }

      if (vismethod == "trajectoryplot") {
          for (i in to_be_tested) {
              p <- plot_cell_trajectory(gbm_cds, markers = i, use_color_gradient = T, show_branch_points = F, show_tree = F, cell_size = opt$pointsize) + theme(legend.text = element_text(size = 10)) + scale_color_gradientn(colours = c("grey", "yellow", "red"))
              ggsave(file.path(output_dir, paste0(i, ".pdf")), bg="white")
              ggsave(file.path(output_dir, paste0(i, ".png")), dpi = 300, bg="white")
          }
      }

      if (vismethod == "module") {
          # retrieve annotation colors
          if ("heatmap" %in% vismethods) {
              gene_clustering <- data.frame(gene_clusters)
              colnames(gene_clustering) <- "gene_module"
          } else if (!is.null(opt$module)) {
              gene_clustering <- data.frame(read.delim(opt$module, header = T, row.names = 1, sep = "\t"))
          } else {
              stop("no gene clustering/module provided.")
          }
          if (is.null(opt$clusters)) {
              print("The number of clusters for the heatmap,the default will be used.")
              clusters_num <- 3
          } else {
              clusters_num <- opt$clusters
          }
          gene_clustering[, 1] <- as.factor(gene_clustering[, 1])
          # colors=unlist(pheatmap:::generate_annotation_colours(gene_clustering,NULL,T),use.names=F)
          colors <- scales::dscale(factor(1:clusters_num), scales::hue_pal(l = 75))
          print("calculating for each module")
          genelist <- list()
          cds_exprs <- list()
          p <- list()
          if (is.null(opt$branchpoint)) {
              print("NO branchpoint is provided, the heatmap without branchtime will be plotted.")
              branchpoint <- NULL
          } else {
              branchpoint <- opt$branchpoint
          }
          if (is.null(branchpoint)) { # without branch
              for (i in unique(gene_clustering[, 1])) {
                  genelist[[i]] <- as.factor(rownames(subset(gene_clustering, gene_module == i)))
                  cds_subset <- gbm_cds[row.names(subset(fData(gbm_cds), gene_short_name %in% levels(genelist[[i]]))), ]
                  cds_exprs[[i]] <- exprs(cds_subset)
                  cds_exprs[[i]] <- Matrix::t(Matrix::t(cds_exprs[[i]]) / sizeFactors(cds_subset))
                  cds_exprs[[i]] <- reshape2::melt(round(as.matrix(cds_exprs[[i]])))
                  min_expr <- cds_subset@lowerDetectionLimit
                  colnames(cds_exprs[[i]]) <- c("f_id", "Cell", "expression")
                  cds_exprs[[i]] <- aggregate(. ~ Cell, data = cds_exprs[[i]], mean) %>% select(f_id, Cell, expression)
                  cds_exprs[[i]]$f_id <- "gene_set"
                  cds_pData <- pData(cds_subset)
                  cds_fData <- fData(cds_subset)
                  cds_exprs[[i]] <- merge(cds_exprs[[i]], cds_pData, by.x = "Cell", by.y = "row.names")
                  cds_exprs[[i]]$adjusted_expression <- cds_exprs[[i]]$expression
                  cds_exprs[[i]]$feature_label <- cds_exprs[[i]]$f_id
                  cds_exprs[[i]]$f_id <- as.character(cds_exprs[[i]]$f_id)
                  cds_exprs[[i]]$feature_label <- factor(cds_exprs[[i]]$feature_label)
                  new_data <- data.frame(Pseudotime = pData(cds_subset)$Pseudotime)
                  model_expectation <- genSmoothCurves(cds_subset, cores = opt$ncores, relative_expr = T, new_data = new_data)
                  colnames(model_expectation) <- colnames(cds_subset)
                  model_expectation <- t(colMeans(model_expectation))
                  rownames(model_expectation) <- "gene_set"
                  expectation <- ddply(cds_exprs[[i]], .(f_id, Cell), function(x) data.frame(expectation = model_expectation[x$f_id, x$Cell]))
                  cds_exprs[[i]] <- merge(cds_exprs[[i]], expectation)
                  cds_exprs[[i]]$expression[cds_exprs[[i]]$expression < min_expr] <- min_expr
                  cds_exprs[[i]]$expectation[cds_exprs[[i]]$expectation < min_expr] <- min_expr
                  saveRDS(cds_exprs, "cds_exprs.rds") # genSmoothCurves() takes time. saving the expectation result just in case
                  p[[i]] <- ggplot() +
                      geom_line(aes(x = Pseudotime, y = expectation), size = 1, colour = colors[as.integer(i)], data = cds_exprs[[i]]) +
                      expand_limits(y = c(min_expr, 1)) +
                      ylab("Relative Expression") +
                      xlab("Pseudo-time") +
                      scale_y_log10() +
                      theme_bw() +
                      theme(panel.grid = element_blank(), panel.border = element_blank(), axis.line = element_line(size = 1, colour = "black"))
                  ggsave(file.path(output_dir, paste0("expressplot_module", i, ".pdf")), plot = p[[i]], width = 5, height = 3, bg="white")
                  ggsave(file.path(output_dir, paste0("expressplot_module", i, ".png")), plot = p[[i]], width = 5, height = 3, bg="white")
              }
          } else { ## branchtime
              new_cds <- buildBranchCellDataSet(gbm_cds, branch_point = branchpoint, progenitor_method = "duplicate")
              cell_fate1 <- unique(pData(new_cds)[which(pData(new_cds)$Branch == unique(pData(new_cds)$Branch)[1]), ]$State)
              cell_fate2 <- unique(pData(new_cds)[which(pData(new_cds)$Branch == unique(pData(new_cds)$Branch)[2]), ]$State)
              branch_labels <- c(paste("State", paste(sort(setdiff(cell_fate1, cell_fate2)), collapse = "-")), paste("State", paste(sort(setdiff(cell_fate2, cell_fate1)), collapse = "-")))
              new_cds <- buildBranchCellDataSet(gbm_cds, branch_point = branchpoint, branch_labels = branch_labels, progenitor_method = "duplicate")
              for (i in unique(gene_clustering[, 1])) {
                  genelist[[i]] <- as.factor(rownames(subset(gene_clustering, gene_module == i)))
                  cds_subset <- new_cds[row.names(subset(fData(new_cds), gene_short_name %in% levels(genelist[[i]]))), ]
                  Branch <- NA
                  CM <- exprs(cds_subset)
                  CM <- Matrix::t(Matrix::t(CM) / sizeFactors(cds_subset))
                  cds_exprs[[i]] <- reshape2::melt(round(as.matrix(CM)))
                  min_expr <- cds_subset@lowerDetectionLimit
                  colnames(cds_exprs[[i]]) <- c("f_id", "Cell", "expression")
                  cds_exprs[[i]] <- aggregate(. ~ Cell, data = cds_exprs[[i]], mean) %>% select(f_id, Cell, expression)
                  cds_exprs[[i]]$f_id <- "gene_set"
                  cds_pData <- pData(cds_subset)
                  cds_fData <- fData(cds_subset)
                  cds_exprs[[i]] <- merge(cds_exprs[[i]], cds_pData, by.x = "Cell", by.y = "row.names")
                  cds_exprs[[i]]$adjusted_expression <- round(cds_exprs[[i]]$expression)
                  cds_exprs[[i]]$feature_label <- cds_exprs[[i]]$f_id
                  cds_exprs[[i]]$feature_label <- as.factor(cds_exprs[[i]]$feature_label)
                  cds_exprs[[i]]$Branch <- as.factor(cds_exprs[[i]]$Branch)
                  new_data <- data.frame(Pseudotime = pData(cds_subset)$Pseudotime, Branch = pData(cds_subset)$Branch)
                  full_model_expectation <- genSmoothCurves(cds_subset,
                      cores = opt$ncores,
                      trend_formula = "~ sm.ns(Pseudotime, df=3) * Branch", relative_expr = T, new_data = new_data
                  )
                  colnames(full_model_expectation) <- colnames(cds_subset)
                  full_model_expectation2 <- t(colMeans(full_model_expectation))
                  rownames(full_model_expectation2) <- "gene_set"
                  cds_exprs[[i]]$full_model_expectation <- apply(cds_exprs[[i]], 1, function(x) full_model_expectation2[x[2], x[1]])
                  cds_exprs[[i]]$feature_label <- cds_exprs[[i]]$f_id
                  cds_exprs[[i]]$feature_label <- factor(cds_exprs[[i]]$feature_label)
                  cds_exprs[[i]]$expression[is.na(cds_exprs[[i]]$expression)] <- min_expr
                  cds_exprs[[i]]$expression[cds_exprs[[i]]$expression < min_expr] <- min_expr
                  cds_exprs[[i]]$full_model_expectation[is.na(cds_exprs[[i]]$full_model_expectation)] <- min_expr
                  cds_exprs[[i]]$full_model_expectation[cds_exprs[[i]]$full_model_expectation < min_expr] <- min_expr
                  cds_exprs[[i]]$State <- as.factor(cds_exprs[[i]]$State)
                  cds_exprs[[i]]$Branch <- as.factor(cds_exprs[[i]]$Branch)
                  saveRDS(cds_exprs, "cds_exprs_branched.rds")
                  p[[i]] <- ggplot(aes(Pseudotime, expression), data = cds_exprs[[i]]) +
                      scale_y_log10() +
                      expand_limits(y = min_expr) +
                      geom_line(aes_string(
                          x = "Pseudotime", y = "full_model_expectation",
                          linetype = "Branch"
                      ), size = 1, color = colors[as.integer(i)], data = cds_exprs[[i]]) +
                      ylab("Expression") +
                      xlab("Pseudotime (stretched)") +
                      theme_bw() +
                      theme(panel.grid = element_blank(), panel.border = element_blank(), axis.line = element_line(size = 1, colour = "black"))
                  ggsave(file.path(output_dir, paste0("expressplot_module", i, "_branchtime.pdf")), plot = p[[i]], width = 5, height = 3, bg="white")
                  ggsave(file.path(output_dir, paste0("expressplot_module", i, "_branchtime.png")), plot = p[[i]], width = 5, height = 3, bg="white")
              }
          }
      }

      if (vismethod == "treeplot") {
          user_color_pal = get_colors(gbm_cds, opt$groupby)
          p <- plot_complex_cell_trajectory(gbm_cds, color_by = opt$groupby, show_branch_points = T, cell_size = opt$pointsize, cell_link_size = 0.3) + scale_colour_manual(values = user_color_pal) + guides(colour = guide_legend(override.aes = list(size = 3)))
          ggsave(file.path(output_dir, paste0("pseudotime_treeplot_colorby_", opt$groupby, ".pdf")), plot = p, bg="white")
          ggsave(file.path(output_dir, paste0("pseudotime_treeplot_colorby_", opt$groupby, ".png")), plot = p, dpi = 300, bg="white")
          p_facet <- plot_complex_cell_trajectory(gbm_cds, color_by = opt$groupby, show_branch_points = T, cell_size = opt$pointsize, cell_link_size = 0.3) + scale_colour_manual(values = user_color_pal) + guides(colour = guide_legend(override.aes = list(size = 3))) + facet_wrap(eval(expr = parse(text = paste0("~ ", opt$groupby))))
          ggsave(file.path(output_dir, paste0("pseudotime_treeplot_colorby_", opt$groupby, "_splited.pdf")), plot = p_facet, width = 10, height = 10, bg="white")
          ggsave(file.path(output_dir, paste0("pseudotime_treeplot_colorby_", opt$groupby, "_splited.png")), plot = p_facet, dpi = 300, width = 10, height = 10, bg="white")
      }

      if (vismethod == "ridgeplot") {
          library(ggridges)
          group_by <- unlist(strsplit(opt$groupby, split = ","))
          for (groupby in group_by){
              if (is.null(opt$branchpoint)) {
                  print("NO branchpoint is provided, the heatmap without branchtime will be plotted.")
                  branchpoint <- NULL
              } else {
                  branchpoint <- opt$branchpoint
              }
              user_color_pal = get_colors(gbm_cds, groupby)
              if (is.null(branchpoint)) { # heatmap without branchtime
                  p <- ggplot(aes_string(x = "Pseudotime", y = groupby , fill = groupby), data = pData(gbm_cds)) +
                          geom_density_ridges() + ylab(groupby) + xlab("Pseudotime") +
                          theme_bw() +  scale_fill_manual(values = user_color_pal) +
                          theme(panel.grid = element_blank(), panel.border = element_blank(), axis.line = element_line(size = 1, colour = "black"),
                            axis.title = element_text(size = 10), legend.text = element_text(size = 6), legend.position = "bottom", legend.title = element_text(size = 6))
                  ggsave(file.path(output_dir, paste0("pseudotime_ridgeplot_colorby_", groupby, ".pdf")), plot = p, width = 10, height = 1 + length(unique(gbm_cds@phenoData@data[,groupby]))/2, bg="white")
                  ggsave(file.path(output_dir, paste0("pseudotime_ridgeplot_colorby_", groupby, ".png")), plot = p, width = 10, height = 1 + length(unique(gbm_cds@phenoData@data[,groupby]))/2, bg="white")
              } else { # heatmap with branchtime
                  new_cds <- buildBranchCellDataSet(gbm_cds, branch_point = branchpoint, progenitor_method = "duplicate")
                  # cell_fate1
                  cell_fate1 <- unique(pData(new_cds)[which(pData(new_cds)$Branch == unique(pData(new_cds)$Branch)[1]), ]$State)
                  # cell_fate2
                  cell_fate2 <- unique(pData(new_cds)[which(pData(new_cds)$Branch == unique(pData(new_cds)$Branch)[2]), ]$State)
                  branch_labels <- c(paste("State", paste(sort(setdiff(cell_fate1, cell_fate2)), collapse = "-")), paste("State", paste(sort(setdiff(cell_fate2, cell_fate1)), collapse = "-")))
                  new_cds <- buildBranchCellDataSet(gbm_cds, branch_point = branchpoint, branch_labels = branch_labels, progenitor_method = "duplicate")
                  p <- ggplot(aes_string(x = "Pseudotime", y = groupby , fill = groupby), data = pData(new_cds)) +
                          geom_density_ridges() + ylab(groupby) + xlab("Pseudotime") + xlim(0,100) + facet_wrap(~Branch, ncol = 2 ) + 
                          theme_bw() + scale_fill_manual(values = user_color_pal) +
                          theme(strip.text.x = element_text( size= 15, colour = "black"), strip.placement = "outside", strip.background.x = element_rect(fill = "transparent", colour = "transparent"), 
                              panel.grid = element_blank(), panel.border = element_blank(), axis.line = element_line(size = 1, colour = "black"),
                              legend.text = element_text(size = 7), legend.position = "bottom")
                  ggsave(file.path(output_dir, paste0("pseudotime_ridgeplot_colorby_", groupby,"_branchtime.pdf")), plot = p, width = 15, height = 2 + length(unique(gbm_cds@phenoData@data[,groupby]))/3, bg="white")
                  ggsave(file.path(output_dir, paste0("pseudotime_ridgeplot_colorby_", groupby,"_branchtime.png")), plot = p, width = 15, height = 2 + length(unique(gbm_cds@phenoData@data[,groupby]))/3, bg="white")
              }
          }
      }
      files <- list.files(path = output_dir, pattern = "\\.(png|pdf)$", full.names = TRUE)
      if (length(files) > 0) {
         file.copy(from = "/public/scRNA_works/Documents/拟时序后续分析说明.docx", to = output_dir)
      }
  }

  if (!is.null(opt$input_sc) && !is.null(opt$sc_genelist)) {
      auc <- readRDSMC(opt$input_sc)

      ## keep barcode number same
      inter <- intersect(colnames(gbm_cds), colnames(auc))
      auc <- auc[, inter]
      gbm_cds <- gbm_cds[, inter]

      ### Replace the expression matrix in pseudotime RDS with AUC matrix
      e.scenic <- rlang::env(exprs = auc@assays$data$AUC)
      assayData(gbm_cds) <- e.scenic

      ### genelist tf as gene "FOXL1 (16g)"
      gene <- read.delim(opt$sc_genelist, sep = "\t")

      to_be_tested <- as.vector(gene[, 1])
      for (i in seq(1, length(to_be_tested), 10)) {
          j <- min(i + 9, length(to_be_tested))
          to_be_tested_sub <- to_be_tested[i:j]
          cds_subset <- gbm_cds[to_be_tested_sub, ]
          user_color_pal = get_colors(cds_subset, opt$groupby)
          p <- plot_tf_auc_in_pseudotime(cds_subset, color_by = opt$groupby, cell_size = opt$pointsize, ncol = opt$numcol, min_expr = 0.0001) + scale_colour_manual(values = user_color_pal) + guides(colour = guide_legend(override.aes = list(size = 1.5)))

          ggsave(file.path(output_dir, paste0("pseudotime_TF_AUC_", basename(opt$sc_genelist), ifelse(i == 1, "", -ceiling(i / 10)), ".pdf")), height = ceiling(length(to_be_tested_sub) / opt$numcol) * 2, bg="white")
          ggsave(file.path(output_dir, paste0("pseudotime_TF_AUC_", basename(opt$sc_genelist), ifelse(i == 1, "", -ceiling(i / 10)), ".png")), height = ceiling(length(to_be_tested_sub) / opt$numcol) * 2, dpi = 300, bg="white")
      }
  }

}  
